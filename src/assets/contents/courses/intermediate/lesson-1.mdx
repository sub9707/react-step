export const metadata = {
  id: 101,
  title: "React Router로 라우팅 마스터하기",
  description: "React Router를 사용하여 SPA에서 페이지 간 이동을 구현하고, 동적 라우팅과 중첩 라우팅을 다뤄봅니다.",
  difficulty: "중간",
  tags: ["React Router", "라우팅", "SPA", "동적 라우팅", "중첩 라우팅", "보호된 라우트"],
  lastUpdated: "2025-08-24",
  image: "/content/intermediate/1/lesson-1-bg.png"
};

import { 
  CalloutBox, 
  ComparisonImages, 
  HighlightWord, 
  Quiz, 
  LinkCard,
  CodeSandbox,
  Image
} from '@/components/CourseContent/EmbeddedComponents'

<Image
  src="/content/intermediate/1/react-router.png"
  alt="React Router 개념도"
  width="half"
/>
<br/>
React로 웹 애플리케이션을 만들다 보면 여러 페이지 간의 이동이 필요한 순간이 옵니다.

일반 웹사이트처럼 페이지마다 새로 로드되는 것이 아니라, <HighlightWord>Single Page Application(SPA)</HighlightWord>에서 부드럽게 화면이 전환되는 것을 구현하려면 라우팅 시스템이 필요합니다.

React Router는 React 애플리케이션에서 가장 널리 사용되는 라우팅 라이브러리입니다.

---

## React Router란?

<HighlightWord>React Router</HighlightWord>는 React 애플리케이션에서 클라이언트 사이드 라우팅을 구현할 수 있게 해주는 라이브러리입니다.

일반 웹사이트에서는 새로운 페이지로 이동할 때마다 서버에서 완전히 새로운 HTML을 받아오지만, SPA에서는 JavaScript로 현재 페이지의 내용만 바꿔주면서 마치 새로운 페이지로 이동한 것처럼 느끼게 해줍니다.

<CalloutBox type="info" title="SPA의 장점">
**빠른 페이지 전환**: 전체 페이지를 다시 로드하지 않고 필요한 부분만 변경

**부드러운 사용자 경험**: 페이지 간 이동 시 깜빡임 없이 자연스러운 전환

**상태 유지**: 페이지 이동 후에도 애플리케이션 상태가 유지됨

**SEO 최적화**: 적절한 URL 구조로 검색 엔진 최적화 가능
</CalloutBox>

---

## React Router 기본 설정

### 1. 설치 및 기본 구조

먼저 React Router를 설치해야 합니다.

```bash
npm install react-router-dom
```

React Router의 기본 구조는 다음과 같습니다:

```jsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

// 페이지 컴포넌트들
function HomePage() {
  return <h1>홈 페이지</h1>;
}

function AboutPage() {
  return <h1>소개 페이지</h1>;
}

function ContactPage() {
  return <h1>연락처 페이지</h1>;
}

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">홈</Link>
        <Link to="/about">소개</Link>
        <Link to="/contact">연락처</Link>
      </nav>
      
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/about" element={<AboutPage />} />
        <Route path="/contact" element={<ContactPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

### 2. 핵심 컴포넌트 이해

React Router의 핵심 컴포넌트들을 살펴보겠습니다:

- **BrowserRouter**: 라우팅 기능을 제공하는 최상위 래퍼
- **Routes**: 여러 Route를 감싸는 컨테이너
- **Route**: 특정 경로와 컴포넌트를 연결
- **Link**: 페이지 간 이동을 위한 링크 (HTML의 `<a>` 태그 대신 사용)

<CalloutBox type="warning" title="Link vs a 태그">
**Link 사용**: SPA의 이점을 활용하여 페이지 새로고침 없이 이동

**a 태그 사용**: 전체 페이지를 새로 로드하므로 SPA의 이점을 잃음

React 애플리케이션 내부 링크는 반드시 Link 컴포넌트를 사용하세요!
</CalloutBox>

### 3. 네비게이션과 레이아웃

실제 애플리케이션에서는 모든 페이지에 공통된 네비게이션이 있을 것입니다:

```jsx
import { BrowserRouter, Routes, Route, Link, Outlet } from 'react-router-dom';

function Layout() {
  return (
    <div>
      <header>
        <nav style={{ padding: '1rem', borderBottom: '1px solid #ccc' }}>
          <Link to="/" style={{ marginRight: '1rem' }}>홈</Link>
          <Link to="/products" style={{ marginRight: '1rem' }}>상품</Link>
          <Link to="/about" style={{ marginRight: '1rem' }}>소개</Link>
        </nav>
      </header>
      
      <main style={{ padding: '2rem' }}>
        <Outlet /> {/* 여기에 각 페이지 컴포넌트가 렌더링됩니다 */}
      </main>
    </div>
  );
}

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Layout />}>
          <Route index element={<HomePage />} />
          <Route path="products" element={<ProductsPage />} />
          <Route path="about" element={<AboutPage />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

`<Outlet />`은 중첩된 라우트에서 자식 컴포넌트가 렌더링될 위치를 지정합니다. Layout 컴포넌트는 모든 페이지에 공통으로 적용되는 UI를 담당합니다.

---

## 동적 라우팅과 파라미터 처리

### 1. URL 파라미터 (URL Parameters)

사용자의 프로필 페이지나 상품 상세 페이지처럼 <HighlightWord>URL에서 변수 값을 받아와서 다른 내용을 보여주는</HighlightWord> 경우가 있습니다. 이를 URL 파라미터라고 합니다.

```jsx
import { useParams, Link } from 'react-router-dom';

// 사용자 목록 페이지
function UsersPage() {
  const users = [
    { id: 1, name: '김리액트' },
    { id: 2, name: '이자바' },
    { id: 3, name: '박파이썬' }
  ];

  return (
    <div>
      <h2>사용자 목록</h2>
      {users.map(user => (
        <div key={user.id}>
          <Link to={`/users/${user.id}`}>{user.name}</Link>
        </div>
      ))}
    </div>
  );
}

// 사용자 상세 페이지
function UserDetailPage() {
  const { userId } = useParams(); // URL에서 파라미터 추출
  
  // 실제로는 API에서 데이터를 가져올 것입니다
  const users = {
    1: { name: '김리액트', email: 'kim@react.com', age: 25 },
    2: { name: '이자바', email: 'lee@java.com', age: 30 },
    3: { name: '박파이썬', email: 'park@python.com', age: 28 }
  };
  
  const user = users[userId];
  
  if (!user) {
    return <h2>사용자를 찾을 수 없습니다.</h2>;
  }
  
  return (
    <div>
      <h2>{user.name}의 프로필</h2>
      <p>이메일: {user.email}</p>
      <p>나이: {user.age}세</p>
      <Link to="/users">목록으로 돌아가기</Link>
    </div>
  );
}

// 라우트 설정
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/users" element={<UsersPage />} />
        <Route path="/users/:userId" element={<UserDetailPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

`useParams()` Hook을 사용하여 URL의 동적 세그먼트를 추출할 수 있습니다. `:userId` 같은 패턴으로 라우트를 정의하면 해당 부분이 파라미터가 됩니다.

### 2. 쿼리 파라미터 (Query Parameters)

URL 뒤에 `?page=1&category=electronics` 같은 형태로 추가 정보를 전달하는 경우도 있습니다:

```jsx
import { useSearchParams } from 'react-router-dom';

function ProductsPage() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const category = searchParams.get('category') || 'all';
  const page = parseInt(searchParams.get('page') || '1');
  
  const handleCategoryChange = (newCategory) => {
    setSearchParams({ category: newCategory, page: 1 });
  };
  
  const handlePageChange = (newPage) => {
    setSearchParams({ category, page: newPage });
  };
  
  return (
    <div>
      <h2>상품 목록</h2>
      <div>
        <button onClick={() => handleCategoryChange('electronics')}>
          전자제품
        </button>
        <button onClick={() => handleCategoryChange('clothing')}>
          의류
        </button>
        <button onClick={() => handleCategoryChange('all')}>
          전체
        </button>
      </div>
      
      <p>현재 카테고리: {category}</p>
      <p>현재 페이지: {page}</p>
      
      <div>
        <button onClick={() => handlePageChange(page - 1)} disabled={page <= 1}>
          이전 페이지
        </button>
        <button onClick={() => handlePageChange(page + 1)}>
          다음 페이지
        </button>
      </div>
    </div>
  );
}
```

`useSearchParams`는 쿼리 파라미터를 읽고 설정할 수 있는 Hook입니다. 검색 필터, 페이지네이션 등에 유용합니다.

---

## 중첩 라우팅

### 1. 중첩 라우팅의 개념

중첩 라우팅은 <HighlightWord>URL의 구조를 계층적으로 구성하여 복잡한 페이지 구조를 관리</HighlightWord>하는 방법입니다. 예를 들어, `/dashboard/analytics`, `/dashboard/settings` 같은 구조를 만들 수 있습니다.

```jsx
import { Outlet, Link, useLocation } from 'react-router-dom';

// 대시보드 레이아웃 컴포넌트
function DashboardLayout() {
  const location = useLocation();
  
  return (
    <div style={{ display: 'flex', minHeight: '100vh' }}>
      {/* 사이드바 */}
      <nav style={{ 
        width: '200px', 
        backgroundColor: '#f5f5f5', 
        padding: '1rem' 
      }}>
        <h3>대시보드</h3>
        <ul style={{ listStyle: 'none', padding: 0 }}>
          <li>
            <Link 
              to="/dashboard" 
              style={{ 
                color: location.pathname === '/dashboard' ? 'blue' : 'black' 
              }}
            >
              개요
            </Link>
          </li>
          <li>
            <Link 
              to="/dashboard/analytics" 
              style={{ 
                color: location.pathname === '/dashboard/analytics' ? 'blue' : 'black' 
              }}
            >
              분석
            </Link>
          </li>
          <li>
            <Link 
              to="/dashboard/settings" 
              style={{ 
                color: location.pathname === '/dashboard/settings' ? 'blue' : 'black' 
              }}
            >
              설정
            </Link>
          </li>
        </ul>
      </nav>
      
      {/* 메인 콘텐츠 영역 */}
      <main style={{ flex: 1, padding: '2rem' }}>
        <Outlet />
      </main>
    </div>
  );
}

// 각 대시보드 페이지들
function DashboardHome() {
  return (
    <div>
      <h2>대시보드 개요</h2>
      <p>전체 현황을 확인할 수 있습니다.</p>
    </div>
  );
}

function AnalyticsPage() {
  return (
    <div>
      <h2>분석</h2>
      <p>상세한 분석 정보를 확인할 수 있습니다.</p>
    </div>
  );
}

function SettingsPage() {
  return (
    <div>
      <h2>설정</h2>
      <p>시스템 설정을 변경할 수 있습니다.</p>
    </div>
  );
}
```

### 2. 중첩 라우팅 설정

```jsx
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<HomePage />} />
        
        {/* 중첩 라우팅 */}
        <Route path="/dashboard" element={<DashboardLayout />}>
          <Route index element={<DashboardHome />} />
          <Route path="analytics" element={<AnalyticsPage />} />
          <Route path="settings" element={<SettingsPage />} />
        </Route>
        
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

`index` 속성을 가진 Route는 부모 경로와 정확히 일치할 때 렌더링됩니다. `/dashboard`로 접근하면 `DashboardHome` 컴포넌트가 표시됩니다.

---

## 보호된 라우트 (Protected Routes)

### 1. 인증이 필요한 페이지 보호하기

실제 애플리케이션에서는 로그인한 사용자만 접근할 수 있는 페이지가 있습니다. <HighlightWord>보호된 라우트</HighlightWord>를 구현해보겠습니다:

```jsx
import { Navigate, useLocation } from 'react-router-dom';

// 인증 상태를 관리하는 간단한 컨텍스트 (실제로는 더 복잡할 것입니다)
function useAuth() {
  // 실제로는 localStorage, 쿠키, 또는 상태 관리 라이브러리에서 가져올 것입니다
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState(null);
  
  const login = (userData) => {
    setIsAuthenticated(true);
    setUser(userData);
  };
  
  const logout = () => {
    setIsAuthenticated(false);
    setUser(null);
  };
  
  return { isAuthenticated, user, login, logout };
}

// 보호된 라우트 컴포넌트
function ProtectedRoute({ children }) {
  const { isAuthenticated } = useAuth();
  const location = useLocation();
  
  if (!isAuthenticated) {
    // 로그인되지 않은 경우 로그인 페이지로 리다이렉트
    // 원래 가려던 페이지 정보를 state로 전달
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return children;
}

// 권한별 접근 제어
function RequireRole({ allowedRoles, children }) {
  const { user } = useAuth();
  
  if (!allowedRoles.includes(user?.role)) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  return children;
}
```

### 2. 보호된 라우트 적용하기

```jsx
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/login" element={<LoginPage />} />
        <Route path="/unauthorized" element={<UnauthorizedPage />} />
        
        {/* 로그인이 필요한 페이지들 */}
        <Route path="/profile" element={
          <ProtectedRoute>
            <ProfilePage />
          </ProtectedRoute>
        } />
        
        {/* 관리자만 접근 가능한 페이지 */}
        <Route path="/admin" element={
          <ProtectedRoute>
            <RequireRole allowedRoles={['admin']}>
              <AdminPage />
            </RequireRole>
          </ProtectedRoute>
        } />
        
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

### 3. 로그인 페이지와 리다이렉트

로그인 성공 후 원래 가려던 페이지로 리다이렉트하는 기능을 구현해보겠습니다:

```jsx
import { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';

function LoginPage() {
  const [credentials, setCredentials] = useState({ username: '', password: '' });
  const { login } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  
  // 원래 가려던 페이지 정보
  const from = location.state?.from?.pathname || '/';
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      // 실제로는 API 호출을 할 것입니다
      const userData = { id: 1, username: credentials.username, role: 'user' };
      login(userData);
      
      // 로그인 성공 후 원래 페이지로 이동
      navigate(from, { replace: true });
    } catch (error) {
      console.error('로그인 실패:', error);
    }
  };
  
  return (
    <div>
      <h2>로그인</h2>
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          placeholder="사용자명"
          value={credentials.username}
          onChange={(e) => setCredentials({
            ...credentials, 
            username: e.target.value
          })}
        />
        <input
          type="password"
          placeholder="비밀번호"
          value={credentials.password}
          onChange={(e) => setCredentials({
            ...credentials, 
            password: e.target.value
          })}
        />
        <button type="submit">로그인</button>
      </form>
    </div>
  );
}
```

---

## 프로그래밍 방식 네비게이션

때로는 사용자의 클릭이 아닌 프로그램 로직에 따라 페이지를 이동해야 할 때가 있습니다:

```jsx
import { useNavigate } from 'react-router-dom';

function CheckoutPage() {
  const navigate = useNavigate();
  const [isProcessing, setIsProcessing] = useState(false);
  
  const handlePayment = async () => {
    setIsProcessing(true);
    
    try {
      // 결제 처리 로직
      const result = await processPayment();
      
      if (result.success) {
        // 결제 성공 시 완료 페이지로 이동
        navigate('/order-complete', { 
          state: { orderId: result.orderId },
          replace: true 
        });
      }
    } catch (error) {
      // 에러 처리
      console.error('결제 실패:', error);
    } finally {
      setIsProcessing(false);
    }
  };
  
  const handleBack = () => {
    // 브라우저의 뒤로가기와 같은 동작
    navigate(-1);
  };
  
  return (
    <div>
      <h2>결제하기</h2>
      <button onClick={handleBack}>이전으로</button>
      <button 
        onClick={handlePayment} 
        disabled={isProcessing}
      >
        {isProcessing ? '처리 중...' : '결제하기'}
      </button>
    </div>
  );
}
```

<CalloutBox type="info" title="navigate 옵션들">
**replace: true**: 브라우저 히스토리에서 현재 항목을 교체 (뒤로가기 시 이전 페이지가 아닌 그 전 페이지로 이동)

**state**: 다음 페이지로 데이터 전달

**숫자 값**: 양수는 앞으로, 음수는 뒤로 이동 (navigate(-1)은 뒤로가기)
</CalloutBox>

---

## 에러 핸들링과 404 페이지

사용자가 존재하지 않는 페이지에 접근했을 때를 대비한 처리도 필요합니다:

```jsx
function NotFoundPage() {
  const navigate = useNavigate();
  
  return (
    <div style={{ textAlign: 'center', padding: '2rem' }}>
      <h1>404 - 페이지를 찾을 수 없습니다</h1>
      <p>요청하신 페이지가 존재하지 않습니다.</p>
      <button onClick={() => navigate('/')}>
        홈으로 돌아가기
      </button>
    </div>
  );
}

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/about" element={<AboutPage />} />
        
        {/* 모든 경로와 매치되지 않는 경우 */}
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

`path="*"`는 다른 모든 라우트와 매치되지 않는 경우에 렌더링됩니다. 반드시 Routes 컴포넌트의 마지막에 위치해야 합니다.

---

## 복습 퀴즈

<Quiz
 question="React Router에서 SPA 내부 페이지 이동 시 사용해야 하는 컴포넌트는?"
 options={[
   "a 태그",
   "Link 컴포넌트", 
   "Navigate 컴포넌트",
   "Route 컴포넌트"
 ]}
 correctAnswer={1}
 explanation="Link 컴포넌트를 사용해야 페이지 새로고침 없이 SPA의 이점을 활용하여 이동할 수 있습니다. a 태그는 전체 페이지를 새로 로드합니다."
/>

<Quiz
 question="URL 파라미터를 추출하기 위해 사용하는 Hook은?"
 options={[
   "useParams()",
   "useSearchParams()",
   "useLocation()",
   "useNavigate()"
 ]}
 correctAnswer={0}
 explanation="useParams() Hook을 사용하여 URL의 동적 세그먼트(:userId 같은)를 추출할 수 있습니다."
/>

<Quiz
 question="중첩 라우팅에서 자식 컴포넌트가 렌더링될 위치를 지정하는 컴포넌트는?"
 options={[
   "Routes",
   "Route",
   "Outlet",
   "Link"
 ]}
 correctAnswer={2}
 explanation="Outlet 컴포넌트는 중첩된 라우트에서 자식 컴포넌트가 렌더링될 위치를 지정합니다."
/>

<Quiz
 question="존재하지 않는 모든 경로를 처리하기 위한 Route의 path 속성 값은?"
 options={[
   "path=\"/404\"",
   "path=\"*\"", 
   "path=\"all\"",
   "path=\"error\""
 ]}
 correctAnswer={1}
 explanation={"path=\"*\"는 다른 모든 라우트와 매치되지 않는 경우를 처리하여 404 페이지를 보여줄 수 있습니다."}
/>

---

## 참고 자료

<LinkCard 
  title="React Router 공식 문서" 
  url="https://reactrouter.com/en/main" 
  description="React Router의 모든 기능과 최신 사용법을 확인할 수 있습니다" 
/>

<LinkCard 
  title="React Router Tutorial" 
  url="https://reactrouter.com/en/main/start/tutorial" 
  description="실습을 통해 React Router를 단계별로 학습할 수 있습니다" 
/>

<LinkCard 
  title="SPA vs MPA 비교" 
  url="https://developer.mozilla.org/en-US/docs/Glossary/SPA" 
  description="Single Page Application의 개념과 장단점에 대해 자세히 알아보세요" 
/>

---

<CalloutBox type="success" title="🎉 라우팅 마스터!">
React Router의 핵심 기능들을 모두 학습했습니다! 이제 복잡한 다중 페이지 React 애플리케이션을 구축할 수 있습니다. 

다음 강의에서는 상태 관리 라이브러리를 활용한 고급 상태 관리 패턴을 배워보겠습니다.
</CalloutBox>