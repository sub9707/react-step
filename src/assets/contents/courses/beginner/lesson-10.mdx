export const metadata = {
  id: 10,
  title: "React 스타일링 방법들",
  description: "React에서 스타일을 적용하는 다양한 방법들을 배워보고, 각각의 장단점과 사용법을 익혀봅시다.",
  difficulty: "쉬움",
  tags: ["React", "CSS", "스타일링", "Tailwind", "styled-components", "SCSS", "CSS 모듈"],
  lastUpdated: "2025-08-20",
  image: "/content/beginner/10/lesson-10-bg.png"
};

import { 
  CalloutBox, 
  ComparisonImages, 
  HighlightWord, 
  Quiz, 
  LinkCard,
  Image
} from '@/components/CourseContent/EmbeddedComponents'

<Image
  src="/content/beginner/10/styling-methods.png"
  alt="React 스타일링 방법들"
  width="two-thirds"
/>

React 개발을 하다 보면 컴포넌트 JSX에 스타일을 적용하는 것이 기존의 HTML/CSS와는 조금 다르다는 것을 느끼게 됩니다.

어떤 방식에선 똑같이 class와 CSS 파일이나 긴 클래스명을 사용하기도 하고, 또 어떤 방식에선 컴포넌트 자체가 스타일이 적용된 상태로 보이기도 합니다.

React에서는 <HighlightWord>다양한 방법으로 스타일을 적용</HighlightWord>할 수 있으며, 각각의 방법마다 고유한 장단점이 있습니다.

이번 회차에서는 React에서 스타일을 적용하는 주요 방법들을 배워보고, 언제 어떤 방법을 사용하는 것이 좋은지 알아보겠습니다.

---

## React에서 스타일링하는 방법들

React에서 스타일을 적용하는 주요 방법들은 다음과 같습니다.

1. **일반 CSS 파일 사용**
2. **인라인 스타일**
3. **CSS 모듈**
4. **CSS-in-JS (styled-components)**
5. **유틸리티 CSS (Tailwind CSS)**
6. **CSS 전처리기 (SCSS/Sass)**

각각의 방법을 자세히 살펴보겠습니다.

---

## 1. 일반 CSS 파일 사용

가장 전통적이고 기존의 HTML/CSS를 사용했다면 익숙한 방법입니다. 

CSS 파일을 컴포넌트별, 레이아웃 등 파일 별도로 만들고 React 컴포넌트에서 import해서 사용합니다.

### 기본 사용법

```css
/* Button.css */

/* 기본 버튼 스타일 */
.btn {
  padding: 12px 24px;
  border: none;
  border-radius: 6px;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.2s ease;
}

/* props에 따라 달라질 스타일 클래스 */
.btn-primary {
  background-color: #3b82f6;
  color: white;
}

.btn-secondary {
  background-color: #6b7280;
  color: white;
}

```

```jsx
// Button.jsx
import './Button.css'; // CSS 파일 import

// Button 컴포넌트는 props로 variant를 넘겨받아 동적으로 스타일을 적용할 수 있습니다
function Button({ variant = 'primary', children, onClick }) {
  return (
    <button 
      className={`btn btn-${variant}`} // 클래스명 조합으로 스타일 적용. variant에 따라 다른 스타일이 적용됩니다
      onClick={onClick}
    >
      {children}
    </button>
  );
}

export default Button;
```

위와 같이 따로 버튼 컴포넌트를 만들었다면 스타일이 서로 다른 컴포넌트로 재사용을 할 수 있겠죠.

variant라는 props만 따로 넘겨주면 넘겨준 값에 따라 어떤 버튼이 될지 결정됩니다.

```jsx
// App.jsx
import Button from './components/Button';

function App() {
  return (
    <div>
      <Button variant="primary">기본 버튼</Button>
      <Button variant="secondary">보조 버튼</Button>
    </div>
  );
}
```

<CalloutBox type="info" title="CSS 파일 import 특징">
**전역 적용**: import한 CSS는 전체 애플리케이션에 적용됩니다. 컴포넌트 별로 따로 적용하기 위해서는 CSS 모듈(button.module.css)이나 CSS-in-JS 방법을 사용해야 합니다

**클래스명 중복 주의**: 다른 컴포넌트와 클래스명이 겹치지 않도록 주의해야 합니다

**간단하고 익숙함**: 기존 CSS 지식을 그대로 활용할 수 있습니다
</CalloutBox>

---

## 2. App.css와 전역 CSS 관리

Create-React-App(CRA) 혹은 vite로 프로젝트를 생성하면 기본적으로 여러 CSS 파일이 생성됩니다. 

각 파일, 폴더마다 명확한 역할과 목적이 있어 적절히 분리해서 관리하는 것이 중요합니다.

### 파일 구조와 각 파일의 역할

React 프로젝트를 생성하면 기본 구조는 다음과 같이 구성됩니다.

```bash
src/ 
├── index.css              # 전역 기본 스타일 (리셋, 타이포그래피, 유틸리티)
├── globals.css            # 전역 공통 스타일 (변수, 테마, 공통 클래스)
├── App.css               # App 컴포넌트 전용 스타일 (메인 레이아웃)
├── styles/
│   ├── variables.css     # CSS 변수 정의
│   ├── reset.css         # 브라우저 기본 스타일 리셋
│   └── themes.css        # 테마별 스타일
└── components/
    ├── Header/
    │   ├── Header.jsx
    │   └── Header.module.css    # Header 컴포넌트 전용 스타일
    └── Button/
        ├── Button.jsx
        └── Button.module.css    # Button 컴포넌트 전용 스타일
```

### 1. index.css - 전역 기본 스타일

index.css는  애플리케이션의 **기초가 되는 전역 스타일**을 담당합니다.

src 경로의 index.js 파일, 혹은 main.jsx에서 바로 import하여 사용합니다. (vite는 main.jsx 혹은 사용 X)
<br/ >
브라우저마다 기본적으로 세팅된 margin, padding 등의 스타일을 리셋하고 통일하기 위함이죠.

프로젝트에 따라 혹은 개발 스타일에 따라 reset.css나 normalize.css를 사용하기도 하고, index.css에 한번에 작성하기도 합니다.

또, 앱 전반적인 기본 글꼴, 줄 간격, 크기 등의 스타일도 작성하고

html, body, #root와 같은 요소들의 레이아웃 스타일도 미리 잡을 수 있습니다.
<br/ >
정리하면, index.css는 <HighlightWord>앱 전체에 공통적으로 초기 셋팅될 스타일을 지정</HighlightWord>하고 싶을 때 사용하는 스타일시트 파일입니다.

예시 파일을 보고 '이렇게도 사용하는구나' 확인하시고 넘어가시면 되겠습니다.

```css
/* index.css - 애플리케이션 전체 기본 스타일 */

/* ===== 리셋 스타일 ===== */
*,
*::before,
*::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* ===== 기본 HTML 요소 스타일 ===== */
html {
  font-size: 16px;
  scroll-behavior: smooth;
  height: 100%;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 
               'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
  line-height: 1.6;
  color: #333333;
  background-color: #ffffff;
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* ===== 기본 타이포그래피 ===== */
h1, h2, h3, h4, h5, h6 {
  font-weight: 600;
  line-height: 1.2;
  margin-bottom: 0.5em;
}

h1 { font-size: 2.5rem; }
h2 { font-size: 2rem; }
h3 { font-size: 1.75rem; }
h4 { font-size: 1.5rem; }
h5 { font-size: 1.25rem; }
h6 { font-size: 1rem; }

p {
  margin-bottom: 1rem;
}

/* ===== 기본 링크 스타일 ===== */
a {
  color: #3b82f6;
  text-decoration: none;
  transition: color 0.2s ease;
}

a:hover {
  color: #1d4ed8;
  text-decoration: underline;
}

```

### 2. globals.css - 전역 공통 스타일

globals.css는 <HighlightWord>프로젝트 전체에서 공통으로 자주 사용되는 스타일</HighlightWord>을 정의합니다.

자주 쓸 CSS 변수나 색상 코드들을 모아둔 팔레트, 자주 쓰는 유틸리티 클래스들을 담는 파일로 프로젝트의 컨벤션을 담는다고 할 수 있습니다.

```css
/* globals.css - 전역 공통 스타일 및 유틸리티 */

/* ===== CSS 변수 (Custom Properties) ===== */
:root {
  /* 컬러 시스템 */
  --color-primary: #3b82f6;
  --color-primary-hover: #2563eb;
  --color-secondary: #6b7280;
  --color-success: #10b981;
  --color-warning: #f59e0b;
  --color-error: #ef4444;
  
  
  /* 폰트 크기 */
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.25rem;
  --font-size-2xl: 1.5rem;
}

/* ===== 다크 테마 ===== */
[data-theme="dark"] {
  --color-text-primary: #f9fafb;
  --color-text-secondary: #d1d5db;
  --color-text-muted: #9ca3af;
  --color-bg-primary: #111827;
  --color-bg-secondary: #1f2937;
  --color-bg-muted: #374151;
  --color-border: #374151;
  --color-border-hover: #4b5563;
}

/* ===== 레이아웃 유틸리티 ===== */
.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--spacing-md);
}

.container-sm { max-width: 640px; }
.container-md { max-width: 768px; }
.container-lg { max-width: 1024px; }
.container-xl { max-width: 1280px; }

/* ===== 텍스트 유틸리티 ===== */
.text-left { text-align: left; }
.text-center { text-align: center; }
.text-right { text-align: right; }
.text-xs { font-size: var(--font-size-xs); }
.text-sm { font-size: var(--font-size-sm); }
.text-base { font-size: var(--font-size-base); }

/* ===== 간격 유틸리티 ===== */
.m-0 { margin: 0; }
.m-1 { margin: var(--spacing-xs); }
.m-2 { margin: var(--spacing-sm); }
.m-4 { margin: var(--spacing-md); }
.p-1 { padding: var(--spacing-xs); }
.p-2 { padding: var(--spacing-sm); }
.p-4 { padding: var(--spacing-md); }
.p-6 { padding: var(--spacing-lg); }

```

tailwind 같은 유틸리티 CSS 를 사용해보신 분들이라면 익숙하실 겁니다.

클래스를 직접 정의해서 필요할 때마다 부르는 방식이니까요.
<br/>

### 3. App.css - 메인 레이아웃 스타일

App.css는 <HighlightWord>App 컴포넌트와 메인 레이아웃</HighlightWord>에만 관련된 스타일을 정의합니다.

헤더, 푸터, 메인 컨텐츠 영역과 같은 앱의 전반적인 레이아웃 틀을 정해놓습니다.

```css
/* App.css - App 컴포넌트 전용 스타일 */

.App {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background-color: var(--color-bg-primary);
  color: var(--color-text-primary);
  transition: background-color 0.3s ease, color 0.3s ease;
}

/* ===== 메인 레이아웃 구조 ===== */
.App-header {
  background: linear-gradient(135deg, var(--color-primary), var(--color-primary-hover));
  color: white;
  padding: var(--spacing-lg) 0;
  box-shadow: var(--shadow-md);
  position: sticky;
  top: 0;
  z-index: 100;
}

.App-main {
  flex: 1;
  padding: var(--spacing-2xl) 0;
  min-height: calc(100vh - 200px); 
}

.App-footer {
  background-color: var(--color-bg-secondary);
  border-top: 1px solid var(--color-border);
  padding: var(--spacing-lg) 0;
  margin-top: auto;
}
```

### CSS 파일 import 순서와 우선순위

올바른 순서로 CSS 파일을 import하는 것이 중요합니다

<HighlightWord>전역 스타일을 가장 먼저 import하고, 그 다음에 컴포넌트별 스타일</HighlightWord>을 순서대로 import해야 합니다.

컴포넌트 스타일을 나중에 import하면 원치않는 전역 스타일링이 적용되는 상황을 막을 수 있습니다.

거꾸로 작성한다면 기껏 꾸민 컴포넌트가 전역 스타일에 먹혀 "왜 적용이 안되지..?"하는 상황이 일어날 수 있어요.

```jsx
// index.js - 전역 스타일을 가장 먼저 import
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';      // 1. 기본 리셋과 타이포그래피
import './globals.css';    // 2. 전역 변수와 유틸리티
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

```jsx
// App.js
import React from 'react';
import './App.css';        // 3. App 컴포넌트 스타일 (전역 스타일 이후)
import Header from './components/Header/Header';
import Button from './components/Button/Button';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <nav className="App-nav">
          <div className="App-nav-brand">My React App</div>
```

### 각 파일별 관리 원칙 정리

각 파일별 특징과 원칙을 정리하고 넘어가겠습니다.

<CalloutBox type="success" title="CSS 파일별 관리 원칙">
**index.css (기본 스타일)**
- HTML 요소의 기본 스타일 리셋
- 타이포그래피 설정
- 접근성 관련 스타일
- 절대 변경되지 않을 기본 스타일만 포함

**globals.css (공통 스타일)**
- CSS 변수 (컬러, 폰트, 간격 등)
- 유틸리티 클래스
- 테마 관련 스타일
- 프로젝트 전체에서 재사용되는 공통 스타일

**App.css (레이아웃 스타일)**
- App 컴포넌트의 메인 레이아웃
- 헤더, 푸터, 네비게이션 등 앱 구조 스타일
- 로딩, 에러 상태 등 앱 레벨 상태 스타일
- App 컴포넌트에만 관련된 스타일

**컴포넌트별 CSS**
- 해당 컴포넌트에만 관련된 스타일
- 컴포넌트의 내부 구조와 상태 스타일
- 다른 컴포넌트에 영향을 주지 않는 독립적인 스타일
</CalloutBox>

---

## 3. CSS 모듈 (CSS Modules)

CSS 모듈은 CSS 클래스명을 지역적으로 범위를 제한하여 클래스명 충돌을 방지하는 방법입니다.

모듈을 사용하면 import한 컴포넌트에서만 적용되는 클래스 스타일을 지정할 수 있습니다.

### CSS 모듈 사용법

파일명을 `[이름].module.css` 형태로 만들어야 합니다.

```css
/* Button.module.css */
.button {
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  background-color: #3b82f6;
  color: white;
  font-size: 16px;
  cursor: pointer;
}

.button:hover {
  background-color: #2563eb;
}
```

```jsx
// Button.jsx
import styles from './Button.module.css';

function Button({ children, onClick }) {
  return (
    <button className={styles.button} onClick={onClick}>
      {children}
    </button>
  );
}

export default Button;
```

위 예시처럼 모듈을 사용하게 된다면 클래스명이 자동으로 고유하게 변합니다.

따라서, 다른 컴포넌트에서 아무리 같은 클래스명을 지정하더라도 겹쳐서 같은 스타일이 적용되는 참사가 없습니다.

```jsx
// 클래스명이 자동으로 고유하게 변환됩니다
// 실제 렌더링: <button class="Button_button__2xY3z Button_primary__1aB2c">

// 다른 컴포넌트에서 같은 클래스명을 사용해도 충돌하지 않습니다
import headerStyles from './Header.module.css';
import buttonStyles from './Button.module.css';

```
두 파일에서 모두 같은 이름의 .primary 클래스가 있어도 서로 다른 고유한 클래스로 변환됩니다.

예: Header.module.css의 .primary와 Button.module.css의 .primary은 서로 다른 클래스명

<CalloutBox type="success" title="CSS 모듈의 장점">
**스코프 격리**: 클래스명이 컴포넌트별로 격리됩니다

**자동 네이밍**: 고유한 클래스명이 자동으로 생성됩니다

**타입 안전성**: TypeScript와 함께 사용하면 클래스명 자동완성을 지원합니다

**기존 CSS 활용**: 기존 CSS 문법을 그대로 사용할 수 있습니다
</CalloutBox>

---

## 4. 인라인 스타일

JSX에서 직접 스타일 객체를 전달하는 방법입니다.

스타일 내용이 있는 객체를 만들어 JSX의 `style` 속성에 전달합니다.

객체로 따로 빼서 ```style={여기!}```에 넣어도 되고, ```style={{}}``` 형태로 바로 작성해도 됩니다.

### 기본 사용법

```jsx
function InlineStyleExample() {
  const boxStyle = {
    width: '200px',
    height: '200px',
    backgroundColor: '#3b82f6',
    border: '2px solid #1e40af',
    borderRadius: '12px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    color: 'white',
    fontSize: '18px',
    fontWeight: 'bold'
  };


  return (
    <div>
      <p style={textStyle}>인라인 스타일 예제</p>
      <div style={{    
        color: '#1f2937',
        fontSize: '16px',
        marginBottom: '10px'
        }}>
        스타일 박스
      </div>
    </div>
  );
}
```

### 동적 스타일링

컴포넌트의 props로 전달받는 값들에 따라 스타일이 다르게 적용되도록 설정할 수 있습니다.

주로 삼항연산자를 스타일 객체 안에 넣어 스타일에서 값(키-값에서의 값)을 선택하거나 className에서 삼항연산자, 혹은 템플릿 리터럴(``` `${변수값 여기!}` ```)을 활용해 동적으로 스타일을 적용합니다.

```jsx
// Button.css
.btn {
  padding: 10px 20px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
}

.btn-primary {
  background: #3b82f6;
  color: white;
}

.btn-secondary {
  background: #6b7280;
  color: white;
}

// Button.jsx
import './Button.css';

function Button({ primary, size, children }) {
  return (
    <button
      // 삼항연산자로 인라인 스타일 적용
      style={{ fontSize: size === 'large' ? '18px' : '14px' }}
      // className에서 삼항연산자 + 템플릿 리터럴로 동적인 클래스 부여
      className={`btn ${primary ? 'btn-primary' : 'btn-secondary'}`}
    >
      {children}
    </button>
  );
}



// 사용 예시
<>
    <Button primary size="large">큰 파란 버튼</Button>
    <Button primary={false} size="small">작은 회색 버튼</Button>
</>
}
```

---

## 5. CSS-in-JS (styled-components)

<Image
  src="/content/beginner/10/styled-components.png"
  alt="styled-components"
  width="half"
/>

CSS-in-JS란 JavaScript 안에서 CSS를 작성하고 관리하는 방식을 의미합니다. 

즉, 기존처럼 .css 파일을 따로 만들어 import하는 것이 아니라, JS 파일 내부에서 스타일을 정의하고, React 컴포넌트처럼 사용할 수 있다는 뜻이에요.

JavaScript 안에서 CSS를 작성하는 방법 중 가장 인기 있는 라이브러리는 Stlyed-components와 Emotion입니다.

그 중 Styled-components를 살펴보겠습니다.

Styled-components는 HTML 요소를 스타일링된 컴포넌트로 만들고 이를 React 컴포넌트처럼 활용합니다.

간단한 예시를 보실까요?

### 설치 및 기본 사용법

```bash
npm install styled-components
```

```jsx
import styled from 'styled-components';

// 기본 스타일드 컴포넌트 - styled 객체를 호출한뒤 뒤에 HTML 요소를 붙여 스타일링된 컴포넌트를 정의

const Button = styled.button`
  padding: 10px 20px;
  border-radius: 6px;
  border: none;
  color: white;
  background: ${p => p.variant === 'primary' ? '#3b82f6' : '#6b7280'};
  &:hover { background: ${p => p.variant === 'primary' ? '#2563eb' : '#4b5563'}; }
  &:disabled { opacity: 0.6; cursor: not-allowed; }
`;

const Card = styled.div`
  padding: 20px; margin: 20px 0; border-radius: 8px;
  background: white; box-shadow: 0 2px 6px rgba(0,0,0,0.1);
`;

const Title = styled.h2` font-size: 20px; margin-bottom: 12px; `;

function App() {
  return (
    <Card>
      <Title>styled-components 예제</Title>
      <Button variant="primary">파란 버튼</Button>
      <Button variant="secondary" disabled>비활성화</Button>
    </Card>
  );
}

export default App;
```

styled-components는 컴포넌트 단위로 스타일을 관리해 앱 내의 스타일 전역 충돌을 막고, props를 활용해 동적으로 스타일을 바꿀 수 있다는 점이 장점입니다.

하지만 런타임 성능 부담과 번들 크기 증가 등이 단점으로 꼽힙니다. 

스타일을 단순히 정적인 CSS 파일로 읽는 게 아니라, 실행 중에 JavaScript 코드로 해석하고 DOM에 ```<style>``` 태그를 그때그떄 삽입하기는 방식이기 때문이에요.

따라서 동적 스타일링과 컴포넌트 캡슐화가 중요한 프로젝트에는 적합하지만, 단순 정적 스타일 위주의 경우라면 CSS Modules이나 전역 CSS로도 충분합니다.

<br/>
또한 다크모드, 라이트 모드와 같은 테마를 지원하는 기능도 제공하여, ThemeProvider를 통해 앱 전체에 일관된 디자인 시스템을 구축할 수 있습니다.

짧은 예시를 보겠습니다.

```jsx
import styled, { ThemeProvider } from "styled-components";

const theme = {
  colors: {
    primary: "#3b82f6",
    secondary: "#6b7280",
  }
};

const Button = styled.button`
  background: ${props => props.theme.colors.primary};
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
`;

function App() {
  return (
    <ThemeProvider theme={theme}>
      <Button>테마 버튼</Button>
    </ThemeProvider>
  );
}

```

객체 형태의 테마를 정의하고 ```ThemeProvider```로 감싸면, styled-components에서 해당 테마를 props로 받아 사용할 수 있습니다.

styled-components로 만든 컴포넌트 내부에서 ```props.theme```으로 접근해 테마 변수에 접근해서 동적으로 스타일을 구현할 수 있는거죠.

```ThemeProvider```로 감싼 컴포넌트에서 이 props에 접근하는 방식이라고 생각하면 됩니다.

<br/>

마지막 기능으로 소개할 것은 **자동 prefix**입니다.

CSS에서 벤더 프리픽스(-webkit-, -moz- 등)를 직접 작성할 필요 없이, styled-components가 자동으로 필요한 프리픽스를 붙여 브라우저끼리의 호환성을 챙겨줍니다.

따로 브라우저별로 일일이 지정할 필요가 없는거죠.


<CalloutBox type="success" title="styled-components의 장점">
**동적 스타일링**: props를 기반으로 한 조건부 스타일링이 쉬움

**스코프 격리**: 컴포넌트별로 스타일이 격리됨

**테마 지원**: ThemeProvider를 통한 일관된 디자인 시스템 구축

**자동 prefix**: 브라우저 호환성을 위한 CSS prefix 자동 추가
</CalloutBox>

---

## 6. Tailwind CSS

<Image
  src="/content/beginner/10/tailwind.png"
  alt="tailwind"
  width="half"
/>

유틸리티 우선 CSS 프레임워크로, 미리 정의된 클래스들을 조합해서 스타일을 만드는 방법입니다.

쉽게 말해, Taiwind에서 미리 정한 클래스명의 스타일을 JSX의 className에 그대로 가져와 사용하는 방식이에요.

### 설치 및 설정

```bash
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

```css
/* src/index.css 혹은 App.css */
@import "tailwindcss"; 
@tailwind utilities; 
```

### 기본 사용법

간단한 사용방식을 보겠습니다.

<Image
  src="/content/beginner/10/Tailwind CSS IntelliSense.png"
  alt="Tailwind CSS IntelliSense"
  width="two-thirds"
/>
vscode에서 Tailwind CSS IntelliSense 확장 프로그램을 설치하면 클래스명을 입력할 때 자동완성을 제공하고, 마우스를 얹어 힌트를 보며 실제로 어떤 CSS가 적용되는지 확인할 수 있습니다.
<br/>
대체로 짧은 줄임말로 클래스명이 구성돼있어요.

mt는 margin-top, p는 padding, bg는 background-color 등으로 앞글자로만 된 형태로 돼있죠.

스타일별로 구분된 클래스명은 아래 공식 Docs에서 찾아볼 수 있습니다.


<LinkCard 
  title="Tailwind CSS 공식 문서" 
  url="https://tailwindcss.com/docs" 
  description="Tailwind CSS의 모든 클래스와 사용법을 확인할 수 있는 공식 문서"
/>

<br/>
tailwind와 관련된 타 라이브러리를 사용하면 tailwind css로 미리 디자인된 컴포넌트를 가져와 쉽게 사용할 수 있습니다.

예를 들어, Flowbite라는 라이브러리가 있습니다.

class를 className으로 바꾸고 사용하면 디자인된 컴포넌트를 가져올 수 있습니다.

<Image
  src="/content/beginner/10/flowbite.png"
  alt="flowbite"
  width="two-thirds"
/>

<LinkCard 
  title="flowbite 공식 문서" 
  url="https://flowbite.com/docs/getting-started/introduction/" 
  description="Tailwind CSS로 만들어진 UI 컴포넌트 라이브러리로, 다양한 컴포넌트를 빠르게 가져와 사용할 수 있습니다."
/>


```jsx
// Tailwind CSS 클래스를 사용한 컴포넌트
function TailwindExample() {
  return (
    <div className="min-h-screen bg-gray-100 py-12 px-4">
      <div className="max-w-md mx-auto bg-white rounded-xl shadow-md overflow-hidden">
        <div className="md:flex">
          <div className="p-8">
            <div className="uppercase tracking-wide text-sm text-indigo-500 font-semibold">
              Tailwind CSS
            </div>
            <h2 className="mt-2 text-xl font-bold text-gray-900">
              간편한 스타일링
            </h2>
            <p className="mt-2 text-gray-600">
              유틸리티 클래스를 조합해서 빠르게 스타일을 적용할 수 있습니다.
            </p>
            <button className="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">
              시작하기
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 컴포넌트별 Tailwind 패턴
Tailwind를 활용하면 스타일을 컴포넌트 내부에서 분리하여 관리할 수 있습니다.

아래는 버튼과 카드, 간단한 레이아웃 예시입니다.

```jsx
// 버튼 컴포넌트
function Button({ variant = 'primary', size = 'medium', children }) {
  const base = "font-medium rounded-lg transition-colors";
  
  const variants = {
    primary: "bg-blue-500 text-white hover:bg-blue-600",
    secondary: "bg-gray-500 text-white hover:bg-gray-600",
  };

  const sizes = {
    small: "px-2 py-1 text-sm",
    medium: "px-4 py-2 text-base",
    large: "px-6 py-3 text-lg",
  };

  return (
    <button className={`${base} ${variants[variant]} ${sizes[size]}`}>
      {children}
    </button>
  );
}

// 카드 컴포넌트
function Card({ title, children }) {
  return (
    <div className="bg-white rounded-lg shadow-md p-4">
      {title && <h3 className="font-semibold mb-2">{title}</h3>}
      {children}
    </div>
  );
}

// 간단한 레이아웃
function Layout() {
  return (
    <div>
      <Card title="카드 1">
        <p>내용 1</p>
        <Button variant="primary" size="small">확인</Button>
      </Card>
      <Card title="카드 2">
        <p>내용 2</p>
        <Button variant="secondary" size="large">취소</Button>
      </Card>
    </div>
  );
}
```
위처럼 기본 스타일 + 변형(variants) + 크기 옵션(sizes) 구조로 만들면,

코드를 재사용 하기 쉬워져 유지보수와 확장이 간편해집니다.

---

## 7. SCSS/Sass

<Image
  src="/content/beginner/10/SCSS.jpg"
  alt="SCSS"
  width="half"
/>


CSS의 확장 언어로, 변수, 중첩, 믹스인 등의 기능을 제공합니다.

SCSS와 Sass는 문법 방식이 조금 다를 뿐 기능은 동일하기 때문에 함께 묶어 부르며, 둘 다 CSS를 확장해 변수, 중첩, 믹스인 등을 제공하는 전처리기 역할을 합니다.

전처리기 방식이란, 개발자가 작성한 확장 문법(SCSS 등)을 <HighlightWord>브라우저가 이해할 수 있는 일반 CSS로 미리 변환하는 처리 방식</HighlightWord>을 말합니다.

<br/>

SCSS는 작성한 코드를 빌드 과정에서 일반 CSS로 변환하는 전처리기 방식으로 동작하며, 기존 CSS 문법을 그대로 사용할 수 있어 진입 장벽이 낮습니다. 

이를 통해 반복되는 값을 변수로 관리하고, 중괄호로 선택자를 중첩해 계층 구조를 직관적으로 표현할 수 있으며, 

믹스인과 함수로 자주 쓰는 스타일을 재사용할 수 있습니다. 

또한 여러 파일로 스타일을 나눠 작성한 뒤 하나의 CSS로 합칠 수 있어 대규모 프로젝트에서 유지보수성과 확장성이 크게 향상됩니다.

주로 컴포넌트 별로 작성하며 컴포넌트 파일과 함께 저장해 관리합니다.

<br/>

사용법을 살펴보겠습니다.
<br/>
### 설치 및 설정<br/>

```bash
npm install sass
```

### SCSS 기본 문법

```scss
// variables.scss - 변수 정의 파일
$primary-color: #3b82f6;
$secondary-color: #6b7280;
$success-color: #10b981;
$danger-color: #ef4444;

$font-size-sm: 14px;
$font-size-base: 16px;
$font-size-lg: 18px;
$font-size-xl: 24px;

// Button.scss
@import './variables';

.button {
  padding: 12px 24px;
  border: none;
  border-radius: $border-radius;
  font-size: $font-size-base;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;

  // 중첩 규칙
  &:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba($primary-color, 0.3);
  }

  // 수식자 클래스
  &--primary {
    background-color: $primary-color;
    color: white;

    &:hover:not(:disabled) {
      background-color: darken($primary-color, 10%);
    }
  }

  &--secondary {
    background-color: $secondary-color;
    color: white;

    &:hover:not(:disabled) {
      background-color: darken($secondary-color, 10%);
    }
  }


  // 크기 변형
  &--small {
    padding: 8px 16px;
    font-size: $font-size-sm;
  }

  &--large {
    padding: 16px 32px;
    font-size: $font-size-lg;
  }
}
```

괄호로 선택자를 중첩하니 보기에 훨씬 직관적이고 이해하는데 쉽지 않나요?

최근 CSS도 중첩 규칙을 지원하지만, 아직은 브라우저 호환성 문제로 SCSS를 사용하는 경우가 많습니다.

이제 믹스인에 대해 알아보겠습니다.

<br/>
### 믹스인(Mixins) 사용

SCSS의 믹스인은 재사용 가능한 스타일 블록을 정의하는 기능입니다.

믹스인을 사용하면 <HighlightWord>반복되는 스타일을 함수처럼 정의하고, 필요할 때마다 호출</HighlightWord>하여 사용할 수 있습니다.

```scss
// mixins.scss

// 요소를 중앙에 배치하는 믹스인
@mixin flex-center {
  display: flex;
  align-items: center;
  justify-content: center;
}

// 카드 스타일을 정의한 믹스인
// 괄호 안의 값은 기본값으로, 호출시 전달하는 값이 없으면 이 값이 사용됩니다.
@mixin card($padding: 24px) {
  background: white;
  border-radius: $border-radius * 2;
  box-shadow: $box-shadow;
  border: 1px solid #e5e7eb;
  padding: $padding;
}

// 반응형 미디어 쿼리를 위한 믹스인
// 기기 크기에 따라 다른 스타일을 적용할 수 있습니다.
// if문을 사용해 직관적으로  브레이크포인트를 지정할 수 있습니다.
@mixin respond-to($breakpoint) {
  @if $breakpoint == mobile {
    @media (max-width: 767px) { @content; }
  }
  @if $breakpoint == tablet {
    @media (min-width: 768px) and (max-width: 1023px) { @content; }
  }
  @if $breakpoint == desktop {
    @media (min-width: 1024px) { @content; }
  }
}

// 믹스인 사용 예시
// 지정한 믹스인은 @include로 호출합니다.
.hero-section {
  @include flex-center;
  height: 400px;
  background: linear-gradient(135deg, $primary-color, $secondary-color);

  .hero-content {
    @include card(40px);
    text-align: center;

    // 모바일 반응형 스타일 적용
    @include respond-to(mobile) {
      padding: 20px;
      margin: 0 20px;
    }
  }
}

```

<CalloutBox type="success" title="SCSS/Sass의 장점">
**변수 시스템**: 일관된 디자인 시스템 구축 가능

**중첩 규칙**: HTML 구조와 유사한 CSS 작성 가능

**믹스인**: 재사용 가능한 스타일 블록 생성

**강력한 기능**: 함수, 조건문, 반복문 등 프로그래밍 기능 제공
</CalloutBox>

<LinkCard 
  title="Sass 공식 문서" 
  url="https://sass-lang.com/documentation" 
  description="CSS 전처리기 Sass/SCSS의 모든 기능과 사용법" 
/>

---

## 스타일링 방법 비교 정리

| 방법 | 장점 | 단점 | 적합한 경우 |
|------|------|------|-------------|
| **일반 CSS** | 익숙함, 간단함, 별도 학습 불필요 | 전역 스타일링, 클래스명 충돌 | 소규모 프로젝트, CSS에 익숙한 팀 |
| **CSS 모듈** | 스코프 격리, 기존 CSS 활용 | 추가 설정 필요, 클래스명 자동 생성 | 중간 규모 프로젝트, 클래스명 충돌 방지 필요 |
| **인라인 스타일** | 동적 스타일링 쉬움, 컴포넌트 격리 | 성능 이슈, 의사 클래스 불가 | 간단한 동적 스타일, 프로토타입 |
| **styled-components** | 강력한 동적 스타일링, 테마 지원 | 번들 크기 증가, 런타임 비용 | 복잡한 UI, 테마 시스템 필요 |
| **Tailwind CSS** | 빠른 개발, 일관성, 최적화 | 학습 곡선, 마크업 복잡 | 빠른 프로토타이핑, 일관된 디자인 시스템 |
| **SCSS/Sass** | 강력한 기능, 변수 시스템 | 컴파일 필요, 복잡할 수 있음 | 대규모 프로젝트, 복잡한 스타일 시스템 |

---

## 복습 퀴즈

<Quiz
 question="React에서 CSS 클래스명 충돌을 방지하는 가장 좋은 방법은?"
 options={[
   "인라인 스타일만 사용하기",
   "CSS 모듈 또는 CSS-in-JS 사용하기",
   "모든 클래스명에 접두사 붙이기",
   "전역 CSS만 사용하기"
 ]}
 correctAnswer={1}
 explanation="CSS 모듈이나 styled-components 같은 CSS-in-JS 라이브러리는 클래스명을 자동으로 고유하게 만들어 충돌을 방지합니다."
/>

<Quiz
 question="인라인 스타일의 단점이 아닌 것은?"
 options={[
   "의사 클래스(:hover)를 사용할 수 없다",
   "매번 새로운 객체가 생성되어 성능에 영향을 줄 수 있다",
   "미디어 쿼리를 사용할 수 없다",
   "컴포넌트별로 스타일이 격리된다"
 ]}
 correctAnswer={3}
 explanation="컴포넌트별 스타일 격리는 인라인 스타일의 장점입니다. 다른 선택지들은 모두 인라인 스타일의 단점에 해당합니다."
/>

<Quiz
 question="Tailwind CSS의 주요 특징이 아닌 것은?"
 options={[
   "유틸리티 우선 접근 방식",
   "사용하지 않는 CSS 자동 제거",
   "컴포넌트별 스타일 격리",
   "반응형 디자인을 위한 접두사 제공"
 ]}
 correctAnswer={2}
 explanation="Tailwind CSS는 전역 유틸리티 클래스를 제공하므로 컴포넌트별 스타일 격리 기능은 없습니다. 이는 CSS 모듈이나 CSS-in-JS의 특징입니다."
/>

<Quiz
 question="SCSS/Sass의 장점이 아닌 것은?"
 options={[
   "변수를 사용할 수 있다",
   "중첩 규칙을 사용할 수 있다",
   "믹스인으로 재사용 가능한 스타일을 만들 수 있다",
   "별도의 컴파일 과정이 필요 없다"
 ]}
 correctAnswer={3}
 explanation="SCSS/Sass는 CSS 전처리기이므로 브라우저에서 실행되기 전에 일반 CSS로 컴파일하는 과정이 필요합니다."
/>

---

## 마무리

<CalloutBox type="success" title="🎉 축하합니다!">
React에서 스타일을 적용하는 다양한 방법들을 모두 학습했습니다! 

각각의 방법은 고유한 장단점이 있으므로, 프로젝트의 규모와 팀의 상황에 맞는 방법을 선택하는 것이 중요합니다.

**추천하는 조합:**
- 소규모 프로젝트: Tailwind CSS + 일반 CSS
- 중대규모 프로젝트: CSS 모듈 + SCSS
- 복잡한 UI가 많은 프로젝트: styled-components + 테마 시스템

다음 회차에서는 React에서 이벤트를 처리하는 방식에 대해 알아보겠습니다.
</CalloutBox>

## 참고 자료

<LinkCard 
  title="React 공식 문서 - 스타일링과 CSS" 
  url="https://ko.react.dev/learn/styling" 
  description="React 공식 문서에서 제공하는 스타일링 가이드" 
/>

<LinkCard 
  title="Tailwind CSS 공식 문서" 
  url="https://tailwindcss.com/docs" 
  description="Tailwind CSS 사용법과 모든 유틸리티 클래스 정보" 
/>

<LinkCard 
  title="styled-components 공식 문서" 
  url="https://styled-components.com/docs" 
  description="CSS-in-JS의 대표 라이브러리 styled-components 사용법" 
/>

<LinkCard 
  title="Sass 공식 문서" 
  url="https://sass-lang.com/documentation" 
  description="CSS 전처리기 Sass/SCSS의 모든 기능과 사용법" 
/>