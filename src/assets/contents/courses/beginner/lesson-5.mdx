export const metadata = {
  id: 5,
  title: "React State 이해하기",
  description: "React 컴포넌트의 상태 관리 핵심 개념인 State와 useState Hook에 대해 학습합니다.",
  difficulty: "쉬움",
  tags: ["React", "State", "useState", "Hook", "상태관리", "입문", "기초"],
  lastUpdated: "2025-07-28",
  image: "/content/beginner/5/state-bg.png"
};

import { 
  CalloutBox, 
  ComparisonImages, 
  HighlightWord, 
  Quiz, 
  LinkCard,
  CodeSandbox,
  Image
} from '@/components/CourseContent/EmbeddedComponents'

<Image
  src="/content/beginner/5/remote-control.png"
  alt="TV 리모컨"
  width="half"
  caption="TV 리모컨으로 채널을 바꾸는 모습"
/>

지난 회차에서는 React의 컴포넌트에 대해 알아보았습니다.

각 컴포넌트는 역할과 기능으로 분리하여 더 큰 컴포넌트를 만들어 앱을 구성합니다.

컴포넌트는 단순히 화면에 무언가를 보여주는 것에서 그치지 않고, 사용자와의 상호작용에 따라 변화하는 정보를 처리해야 합니다.

예를 들어 버튼을 클릭하면 숫자가 증가하거나, 입력창에 문자를 입력하면 화면에 실시간으로 반영되는 등 동적인 동작이 필요하죠.

이러한 동작을 구현하려면 컴포넌트 내부에서 데이터를 저장하고 변경할 수 있는 방법이 필요합니다.

그렇다면 컴포넌트는 자기 안에 있는 변수, 데이터를 어떻게 기억할까요?

---

## State란 무엇인가?

<HighlightWord>State(상태)</HighlightWord>는 React 컴포넌트가 기억하고 있는 **데이터**입니다.

시간이 지나면서 변할 수 있는 모든 정보가 State가 될 수 있어요.

<Image
  src="/content/beginner/5/state-concept.png"
  alt="State 개념 설명"
  width="full"
  caption="State는 컴포넌트가 기억하는 변화 가능한 데이터"
/>

State의 특징:
- **기억 가능**: 컴포넌트가 데이터를 기억하고 있음
- **변화 가능**: 사용자 행동이나 시간에 따라 값이 바뀔 수 있음
- **반응형**: State가 바뀌면 화면이 자동으로 다시 그려짐

<CalloutBox type="info" title="State의 예시">
웹사이트에서 볼 수 있는 State들:

**카운터**: 0, 1, 2, 3... (숫자가 변함)

**로그인 상태**: "로그인됨" 또는 "로그아웃됨"

**장바구니**: 담긴 상품들의 목록

**다크모드**: "밝은 테마" 또는 "어두운 테마"

**입력 폼**: 사용자가 입력하는 텍스트
</CalloutBox>

---

## State가 없다면?

State 없이 만든 컴포넌트를 먼저 살펴보겠습니다.

<CodeSandbox
title="State 없는 컴포넌트 - 버튼을 눌러도 변화 없음"
code={`function NoStateCounter() {
  let count = 0; // 일반 변수

  const handleClick = () => {
    count = count + 1;
    console.log('현재 count:', count);
  };

  return (
    <div style={{padding: '20px', textAlign: 'center', backgroundColor: '#f8fafc', borderRadius: '8px'}}>
      <h3>State 없는 카운터</h3>
      <p style={{fontSize: '24px'}}>현재 숫자: {count}</p>
      <button onClick={handleClick} style={{padding: '10px 20px', backgroundColor: '#3b82f6', color: 'white', border: 'none', borderRadius: '6px'}}>
        +1 증가
      </button>
      <p style={{fontSize: '12px', color: '#666'}}>버튼을 클릭해보세요! (화면에는 변화가 없습니다)</p>
    </div>
  );
}

function App() {
  return <NoStateCounter />;
}`}
/>

버튼을 클릭해보세요. 개발자 도구의 콘솔에는 숫자가 증가하지만, 화면의 숫자는 그대로 0입니다.

<CalloutBox type="warning" title="일반 변수의 문제점">
**화면이 업데이트되지 않음**: 변수값이 바뀌어도 React가 모름

**값이 유지되지 않음**: 컴포넌트가 다시 렌더링되면 변수는 초기값으로 돌아감

**React의 특징을 활용 못함**: Virtual DOM의 최적화 혜택을 받을 수 없음
</CalloutBox>

---

## useState Hook 등장

이 문제를 해결하기 위해 React는 <HighlightWord>useState Hook</HighlightWord>을 제공합니다.

```javascript
import { useState } from 'react';

function MyComponent() {
  const [state, setState] = useState(초기값);
  
  // state: 현재 상태값
  // setState: 상태를 바꾸는 함수
  // 초기값: 처음에 설정할 값
}
```

<Image
  src="/content/beginner/5/usestate-anatomy.png"
  alt="useState 구조 분석"
  width="full"
  caption="useState Hook의 구조와 반환값"
/>

useState가 반환하는 것:
1. **현재 상태값** (state)
2. **상태 변경 함수** (setState)

<CalloutBox type="success" title="useState의 특징">
**배열 구조분해**: `[state, setState] = useState()`

**자동 리렌더링**: setState 호출시 컴포넌트가 자동으로 다시 그려짐

**상태 보존**: 컴포넌트가 화면에 있는 동안 상태값이 유지됨

**함수형 컴포넌트 전용**: Hook은 함수형 컴포넌트에서만 사용 가능
</CalloutBox>

---

## 실제 State 사용해보기

이제 useState를 사용해서 제대로 작동하는 카운터를 만들어보겠습니다.

<CodeSandbox
title="useState를 사용한 카운터 - 제대로 작동함"
code={`function StateCounter() {
  const [count, setCount] = React.useState(0);

  return (
    <div style={{padding: '20px', textAlign: 'center', backgroundColor: '#f0f9ff', borderRadius: '8px'}}>
      <h3>useState 카운터</h3>
      <p style={{fontSize: '36px', color: '#1e40af', fontWeight: 'bold'}}>{count}</p>
      <div style={{display: 'flex', gap: '10px', justifyContent: 'center'}}>
        <button onClick={() => setCount(count - 1)} style={{padding: '10px 20px', backgroundColor: '#ef4444', color: 'white', border: 'none', borderRadius: '6px'}}>
          -1
        </button>
        <button onClick={() => setCount(0)} style={{padding: '10px 20px', backgroundColor: '#6b7280', color: 'white', border: 'none', borderRadius: '6px'}}>
          초기화
        </button>
        <button onClick={() => setCount(count + 1)} style={{padding: '10px 20px', backgroundColor: '#10b981', color: 'white', border: 'none', borderRadius: '6px'}}>
          +1
        </button>
      </div>
    </div>
  );
}

function App() {
  return <StateCounter />;
}`}
/>

이번에는 버튼을 클릭하면 화면의 숫자가 실시간으로 바뀝니다! useState 덕분에 React가 상태 변화를 감지하고 화면을 자동으로 업데이트해주기 때문입니다.

---

## State 업데이트 과정

State가 어떻게 업데이트되는지 단계별로 살펴보겠습니다.

<Image
  src="/content/beginner/5/state-update-process.png"
  alt="State 업데이트 과정"
  width="full"
  caption="State 업데이트가 일어나는 과정 (4단계)"
/>

### 1단계: 이벤트 발생
```javascript
<button onClick={handleIncrement}>+1</button>
// 사용자가 버튼 클릭
```

### 2단계: setState 함수 호출
```javascript
const handleIncrement = () => {
  setCount(count + 1); // setCount 호출
};
```

### 3단계: React가 상태 변화 감지
React는 setCount가 호출된 것을 감지하고 해당 컴포넌트를 **리렌더링 대기열**에 추가합니다.

### 4단계: 컴포넌트 리렌더링
React가 컴포넌트 함수를 다시 실행하고, 새로운 count 값으로 Virtual DOM을 업데이트한 후 실제 DOM에 반영합니다.

<CalloutBox type="info" title="리렌더링이란?">
**리렌더링**: 컴포넌트 함수가 다시 실행되어 새로운 JSX를 생성하는 과정

**트리거**: State 변경, Props 변경, 부모 컴포넌트 리렌더링

**최적화**: React는 Virtual DOM을 통해 실제로 바뀐 부분만 업데이트
</CalloutBox>

---

## 다양한 타입의 State

State는 숫자뿐만 아니라 다양한 데이터 타입을 저장할 수 있습니다.

<CodeSandbox
title="다양한 타입의 State 예제"
code={`function VariousStates() {
  const [message, setMessage] = React.useState('안녕하세요!');
  const [isVisible, setIsVisible] = React.useState(true);
  const [items, setItems] = React.useState(['사과', '바나나']);
  const [user, setUser] = React.useState({ name: '김리액트', age: 25 });

  return (
    <div style={{padding: '20px', backgroundColor: '#f9fafb', borderRadius: '12px'}}>
      <h3>다양한 State 타입들</h3>
      
      {/* 문자열 State */}
      <div style={{marginBottom: '15px', padding: '10px', backgroundColor: 'white', borderRadius: '6px'}}>
        <h4>문자열: {message}</h4>
        <button onClick={() => setMessage('메시지가 바뀌었어요!')}>변경</button>
      </div>

      {/* 불린 State */}
      <div style={{marginBottom: '15px', padding: '10px', backgroundColor: 'white', borderRadius: '6px'}}>
        <h4>불린: {isVisible && <span>보입니다!</span>}</h4>
        <button onClick={() => setIsVisible(!isVisible)}>{isVisible ? '숨기기' : '보이기'}</button>
      </div>

      {/* 배열 State */}
      <div style={{marginBottom: '15px', padding: '10px', backgroundColor: 'white', borderRadius: '6px'}}>
        <h4>배열: {items.join(', ')}</h4>
        <button onClick={() => setItems([...items, '오렌지'])}>과일 추가</button>
      </div>

      {/* 객체 State */}
      <div style={{padding: '10px', backgroundColor: 'white', borderRadius: '6px'}}>
        <h4>객체: {user.name} ({user.age}세)</h4>
        <button onClick={() => setUser({...user, age: user.age + 1})}>나이 +1</button>
      </div>
    </div>
  );
}

function App() {
  return <VariousStates />;
}`}
/>

<CalloutBox type="warning" title="객체와 배열 State 주의사항">
**불변성 유지**: 기존 객체/배열을 직접 수정하지 말고 새로운 객체/배열을 만들어야 함

**스프레드 연산자 활용**: `...` 연산자로 기존 데이터를 복사한 후 수정

**잘못된 예**: `user.age = 26` (직접 수정)

**올바른 예**: `setUser({...user, age: 26})` (새 객체 생성)
</CalloutBox>

---

## State 업데이트 시 주의사항

### 1. State는 비동기적으로 업데이트됩니다

<CodeSandbox
title="State 비동기 업데이트 이해하기"
code={`function AsyncStateExample() {
  const [count, setCount] = React.useState(0);

  const handleWrongUpdate = () => {
    console.log('업데이트 전:', count);
    setCount(count + 1);
    console.log('setCount 호출 직후:', count); // 여전히 이전 값!
  };

  const handleMultipleUpdates = () => {
    setCount(count + 1); // 모두 같은 값 기준으로 계산됨
    setCount(count + 1);
    setCount(count + 1);
  };

  const handleCorrectMultipleUpdates = () => {
    setCount(prev => prev + 1); // 이전 값을 기준으로 계산
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
  };

  return (
    <div style={{padding: '20px', backgroundColor: '#fef3c7', borderRadius: '12px'}}>
      <h3>State 비동기 업데이트</h3>
      <p style={{fontSize: '24px', textAlign: 'center'}}>현재 count: {count}</p>
      
      <div style={{display: 'flex', flexDirection: 'column', gap: '8px'}}>
        <button onClick={handleWrongUpdate} style={{padding: '8px', backgroundColor: '#f59e0b', color: 'white', border: 'none', borderRadius: '4px'}}>
          일반 업데이트 (+1)
        </button>
        <button onClick={handleMultipleUpdates} style={{padding: '8px', backgroundColor: '#ef4444', color: 'white', border: 'none', borderRadius: '4px'}}>
          잘못된 다중 업데이트 (+1만 됨!)
        </button>
        <button onClick={handleCorrectMultipleUpdates} style={{padding: '8px', backgroundColor: '#3b82f6', color: 'white', border: 'none', borderRadius: '4px'}}>
          올바른 다중 업데이트 (+3)
        </button>
      </div>
      
      <p style={{fontSize: '12px', color: '#92400e', marginTop: '10px'}}>
        콘솔을 확인하여 각 버튼의 동작을 비교해보세요!
      </p>
    </div>
  );
}

function App() {
  return <AsyncStateExample />;
}`}
/>

### 2. 함수형 업데이트 사용하기

이전 State 값을 기반으로 새로운 값을 계산할 때는 **함수형 업데이트**를 사용하세요.

```javascript
// 잘못된 방법
setCount(count + 1);

// 올바른 방법
setCount(prevCount => prevCount + 1);
```

<CalloutBox type="success" title="함수형 업데이트의 장점">
**정확한 업데이트**: 항상 최신 상태값을 기준으로 계산

**다중 업데이트 안전**: 여러 번 호출해도 정상 작동

**성능 최적화**: React의 배치 업데이트와 잘 동작
</CalloutBox>

---

## State와 이벤트 처리

실제 웹 애플리케이션에서는 사용자의 다양한 이벤트에 따라 State를 업데이트합니다.

<CodeSandbox
title="실용적인 폼 관리 예제"
code={`function InteractiveForm() {
  const [name, setName] = React.useState('');
  const [email, setEmail] = React.useState('');
  const [isSubmitted, setIsSubmitted] = React.useState(false);

  const handleSubmit = (e) => {
    e.preventDefault();
    setIsSubmitted(true);
    setTimeout(() => {
      setName('');
      setEmail('');
      setIsSubmitted(false);
    }, 2000);
  };

  if (isSubmitted) {
    return (
      <div style={{padding: '20px', textAlign: 'center', backgroundColor: '#dcfce7', borderRadius: '8px'}}>
        <h3 style={{color: '#166534'}}>제출 완료!</h3>
        <p>안녕하세요, {name}님!</p>
        <p>2초 후 자동으로 초기화됩니다...</p>
      </div>
    );
  }

  return (
    <div style={{padding: '20px', backgroundColor: '#f8fafc', borderRadius: '8px'}}>
      <h3>연락처 폼</h3>
      <form onSubmit={handleSubmit} style={{display: 'flex', flexDirection: 'column', gap: '10px'}}>
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="이름을 입력하세요"
          style={{padding: '8px', border: '1px solid #d1d5db', borderRadius: '4px'}}
          required
        />
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="이메일을 입력하세요"
          style={{padding: '8px', border: '1px solid #d1d5db', borderRadius: '4px'}}
          required
        />
        <button type="submit" style={{padding: '10px', backgroundColor: '#3b82f6', color: 'white', border: 'none', borderRadius: '4px'}}>
          제출하기
        </button>
      </form>

      {(name || email) && (
        <div style={{marginTop: '15px', padding: '10px', backgroundColor: '#e0f2fe', borderRadius: '4px'}}>
          <h4 style={{margin: '0 0 5px 0', color: '#0369a1'}}>실시간 미리보기:</h4>
          {name && <p>이름: {name}</p>}
          {email && <p>이메일: {email}</p>}
        </div>
      )}
    </div>
  );
}

function App() {
  return <InteractiveForm />;
}`}
/>

위 예제에서 볼 수 있듯이, State를 통해 다음과 같은 기능을 구현할 수 있습니다:

- **폼 입력 관리**: 사용자 입력을 실시간으로 State에 저장
- **조건부 렌더링**: State에 따라 다른 화면을 보여줌
- **실시간 미리보기**: 입력한 내용을 즉시 화면에 반영

---

## 여러 컴포넌트 간 State 공유

때로는 여러 컴포넌트가 같은 State를 공유해야 할 때가 있습니다. 이때는 **State를 상위 컴포넌트로 끌어올리기(State Lifting)**를 사용합니다.

<CodeSandbox
title="State 끌어올리기 - 형제 컴포넌트 간 State 공유"
code={`function Counter({ count, onIncrement, onDecrement }) {
  return (
    <div style={{padding: '15px', backgroundColor: '#e0f2fe', borderRadius: '6px', textAlign: 'center'}}>
      <h4>카운터</h4>
      <p style={{fontSize: '20px'}}>{count}</p>
      <button onClick={onDecrement} style={{margin: '0 5px', padding: '5px 10px', backgroundColor: '#ef4444', color: 'white', border: 'none', borderRadius: '4px'}}>-1</button>
      <button onClick={onIncrement} style={{margin: '0 5px', padding: '5px 10px', backgroundColor: '#10b981', color: 'white', border: 'none', borderRadius: '4px'}}>+1</button>
    </div>
  );
}

function Display({ count }) {
  const getColor = () => count > 5 ? '#dc2626' : count < 0 ? '#2563eb' : '#059669';
  
  return (
    <div style={{padding: '15px', backgroundColor: '#fef3c7', borderRadius: '6px', textAlign: 'center'}}>
      <h4>디스플레이</h4>
      <p style={{fontSize: '32px', color: getColor(), fontWeight: 'bold'}}>{count}</p>
    </div>
  );
}

function Reset({ onReset }) {
  return (
    <div style={{padding: '15px', backgroundColor: '#f3e8ff', borderRadius: '6px', textAlign: 'center'}}>
      <h4>리셋</h4>
      <button onClick={onReset} style={{padding: '8px 16px', backgroundColor: '#8b5cf6', color: 'white', border: 'none', borderRadius: '4px'}}>
        0으로 리셋
      </button>
    </div>
  );
}

function StateLiftingExample() {
  const [count, setCount] = React.useState(0);

  return (
    <div style={{padding: '20px', backgroundColor: '#f9fafb', borderRadius: '12px'}}>
      <h3 style={{textAlign: 'center', marginBottom: '15px'}}>State 끌어올리기 예제</h3>
      <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '10px'}}>
        <Counter count={count} onIncrement={() => setCount(count + 1)} onDecrement={() => setCount(count - 1)} />
        <Display count={count} />
        <Reset onReset={() => setCount(0)} />
      </div>
    </div>
  );
}

function App() {
  return <StateLiftingExample />;
}`}
/>

위 예제에서 중요한 점은 **State를 공유해야 하는 컴포넌트들의 가장 가까운 공통 부모에서 State를 관리**한다는 것입니다.

<CalloutBox type="success" title="State 끌어올리기의 장점">
**데이터 일관성**: 모든 컴포넌트가 같은 데이터를 보게 됨

**단일 소스**: State가 한 곳에서만 관리되어 버그 방지

**예측 가능한 데이터 흐름**: 부모→자식으로만 데이터가 흐름

**컴포넌트 재사용성**: 자식 컴포넌트들이 독립적으로 재사용 가능
</CalloutBox>

---

## State 관리 패턴과 베스트 프랙티스

### 1. State 구조 설계하기

<CalloutBox type="info" title="좋은 State 구조의 원칙">
**단순하게 유지**: 가능한 한 간단한 구조로 설계

**정규화**: 중복 데이터를 피하고 단일 소스 유지

**최소한의 State**: 계산 가능한 값은 State로 저장하지 않기

**논리적 그룹핑**: 관련된 데이터는 하나의 객체로 묶기
</CalloutBox>

```javascript
// 좋지 않은 예 - 중복 데이터
const [firstName, setFirstName] = useState('김');
const [lastName, setLastName] = useState('리액트');
const [fullName, setFullName] = useState('김리액트'); // 불필요!

// 좋은 예 - 필요한 것만 State로
const [firstName, setFirstName] = useState('김');
const [lastName, setLastName] = useState('리액트');
const fullName = `${firstName}${lastName}`; // 계산된 값
```

### 2. State 업데이트 패턴

<ComparisonImages
  leftImage={{
    src: "/content/beginner/5/wrong-state-update.png",
    alt: "잘못된 State 업데이트",
    caption: "직접 수정 - React가 변화를 감지하지 못함"
  }}
  rightImage={{
    src: "/content/beginner/5/correct-state-update.png",
    alt: "올바른 State 업데이트",
    caption: "새 객체/배열 생성 - React가 변화를 정확히 감지"
  }}
  labels={{ left: "잘못된 방법", right: "올바른 방법" }}
/>

```javascript
// 배열 State 업데이트 패턴
const [todos, setTodos] = useState([]);

// 추가
setTodos([...todos, newTodo]);

// 수정
setTodos(todos.map(todo => 
  todo.id === targetId ? { ...todo, completed: true } : todo
));

// 삭제
setTodos(todos.filter(todo => todo.id !== targetId));

// 객체 State 업데이트 패턴
const [user, setUser] = useState({ name: '', age: 0 });

// 부분 업데이트
setUser({ ...user, age: 25 });
```

---

## 실무에서 자주 사용하는 State 패턴

### 로딩 상태 관리

<CodeSandbox
title="로딩 상태 관리 패턴"
code={`function LoadingExample() {
  const [data, setData] = React.useState(null);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState(null);

  const fetchData = async () => {
    setLoading(true);
    setError(null);
    
    try {
      await new Promise(resolve => setTimeout(resolve, 1500));
      setData({ title: '데이터 로드 완료!', content: 'State 관리로 로딩을 처리했습니다.' });
    } catch (err) {
      setError('데이터 로드에 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{padding: '20px', backgroundColor: '#f8fafc', borderRadius: '8px', minHeight: '200px'}}>
      <h3>로딩 상태 관리</h3>
      
      <button onClick={fetchData} disabled={loading} style={{padding: '8px 16px', backgroundColor: loading ? '#9ca3af' : '#3b82f6', color: 'white', border: 'none', borderRadius: '4px', marginBottom: '15px'}}>
        {loading ? '로딩중...' : '데이터 불러오기'}
      </button>

      {loading && (
        <div style={{textAlign: 'center', padding: '20px', backgroundColor: '#e0f2fe', borderRadius: '6px'}}>
          <p>데이터를 불러오는 중입니다...</p>
        </div>
      )}

      {error && (
        <div style={{padding: '15px', backgroundColor: '#fef2f2', border: '1px solid #fecaca', borderRadius: '6px', color: '#dc2626'}}>
          <p>{error}</p>
        </div>
      )}

      {data && !loading && (
        <div style={{padding: '15px', backgroundColor: '#f0fdf4', border: '1px solid #bbf7d0', borderRadius: '6px'}}>
          <h4 style={{color: '#166534'}}>{data.title}</h4>
          <p>{data.content}</p>
        </div>
      )}

      {!data && !loading && !error && (
        <div style={{textAlign: 'center', padding: '20px', color: '#6b7280'}}>
          <p>버튼을 클릭하여 데이터를 불러보세요!</p>
        </div>
      )}
    </div>
  );
}

function App() {
  return <LoadingExample />;
}`}
/>

### 폼 유효성 검사

<CodeSandbox
title="폼 유효성 검사 패턴"
code={`function ValidationForm() {
  const [formData, setFormData] = React.useState({ username: '', email: '' });
  const [errors, setErrors] = React.useState({});

  const validate = (name, value) => {
    if (name === 'username') {
      return !value ? '사용자명을 입력해주세요.' : value.length < 3 ? '3자 이상 입력하세요.' : '';
    }
    if (name === 'email') {
      return !value ? '이메일을 입력해주세요.' : !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) ? '올바른 이메일 형식이 아닙니다.' : '';
    }
    return '';
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    const error = validate(name, value);
    setErrors(prev => ({ ...prev, [name]: error }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const newErrors = {};
    Object.keys(formData).forEach(key => {
      const error = validate(key, formData[key]);
      if (error) newErrors[key] = error;
    });

    setErrors(newErrors);
    if (Object.keys(newErrors).length === 0) {
      alert('제출 완료!');
      setFormData({ username: '', email: '' });
    }
  };

  return (
    <div style={{padding: '20px', backgroundColor: '#f9fafb', borderRadius: '8px', maxWidth: '300px'}}>
      <h3>유효성 검사 폼</h3>
      <form onSubmit={handleSubmit} style={{display: 'flex', flexDirection: 'column', gap: '10px'}}>
        <div>
          <input
            name="username"
            value={formData.username}
            onChange={handleChange}
            placeholder="사용자명"
            style={{width: '100%', padding: '8px', border: \`1px solid \${errors.username ? '#ef4444' : '#d1d5db'}\`, borderRadius: '4px'}}
          />
          {errors.username && <p style={{color: '#ef4444', fontSize: '12px', margin: '2px 0'}}>{errors.username}</p>}
        </div>

        <div>
          <input
            name="email"
            value={formData.email}
            onChange={handleChange}
            placeholder="이메일"
            style={{width: '100%', padding: '8px', border: \`1px solid \${errors.email ? '#ef4444' : '#d1d5db'}\`, borderRadius: '4px'}}
          />
          {errors.email && <p style={{color: '#ef4444', fontSize: '12px', margin: '2px 0'}}>{errors.email}</p>}
        </div>

        <button type="submit" style={{padding: '10px', backgroundColor: '#10b981', color: 'white', border: 'none', borderRadius: '4px'}}>
          제출
        </button>
      </form>
    </div>
  );
}

function App() {
  return <ValidationForm />;
}`}
/>

---

## State 성능 최적화

대규모 애플리케이션에서는 State 업데이트로 인한 성능 문제를 고려해야 합니다.

<CalloutBox type="warning" title="성능 문제의 원인">
**과도한 State**: 너무 많은 State를 하나의 컴포넌트에서 관리

**빈번한 업데이트**: 짧은 시간에 많은 State 변경

**큰 객체/배열**: 거대한 데이터 구조를 State로 관리

**불필요한 리계산**: 매 렌더링마다 복잡한 계산 수행
</CalloutBox>

### State 분할하기

```javascript
// 좋지 않은 예 - 모든 것을 하나의 객체로
const [appState, setAppState] = useState({
  user: { name: '', email: '' },
  todos: [],
  filters: { completed: false },
  ui: { loading: false, theme: 'light' }
});

// 좋은 예 - 관련된 것끼리 분할
const [user, setUser] = useState({ name: '', email: '' });
const [todos, setTodos] = useState([]);
const [filters, setFilters] = useState({ completed: false });
const [ui, setUi] = useState({ loading: false, theme: 'light' });
```

---

## State vs Props 비교

State와 Props의 차이점을 명확히 이해하는 것이 중요합니다.

| 구분 | State | Props |
|------|-------|-------|
| **소유권** | 컴포넌트가 직접 소유 | 부모 컴포넌트가 전달 |
| **변경 가능성** | 컴포넌트 내에서 변경 가능 | 읽기 전용 (불변) |
| **용도** | 컴포넌트의 내부 상태 관리 | 컴포넌트 간 데이터 전달 |
| **리렌더링** | 변경시 자동 리렌더링 | 변경시 자동 리렌더링 |

<ComparisonImages
  leftImage={{
    src: "/content/beginner/5/state-flow.png",
    alt: "State 데이터 흐름",
    caption: "State는 컴포넌트 내부에서 관리"
  }}
  rightImage={{
    src: "/content/beginner/5/props-flow.png",
    alt: "Props 데이터 흐름",
    caption: "Props는 부모에서 자식으로 전달"
  }}
  labels={{ left: "State", right: "Props" }}
/>

---

## 고급 State 패턴 맛보기

### 1. Reducer 패턴 (useReducer)

복잡한 State 로직의 경우 useState 대신 useReducer를 사용할 수 있습니다.

```javascript
// 복잡한 상태 관리가 필요한 경우
const initialState = { count: 0, step: 1 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + state.step };
    case 'setStep':
      return { ...state, step: action.payload };
    case 'reset':
      return initialState;
    default:
      return state;
  }
}

function ComplexCounter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  return (
    <div>
      <p>Count: {state.count} (Step: {state.step})</p>
      <button onClick={() => dispatch({ type: 'increment' })}>
        +{state.step}
      </button>
    </div>
  );
}
```

### 2. 커스텀 Hook으로 State 로직 분리

```javascript
// 재사용 가능한 State 로직을 커스텀 Hook으로
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);
  
  return { count, increment, decrement, reset };
}

// 사용
function MyComponent() {
  const counter = useCounter(10);
  
  return (
    <div>
      <p>{counter.count}</p>
      <button onClick={counter.increment}>+</button>
      <button onClick={counter.decrement}>-</button>
      <button onClick={counter.reset}>Reset</button>
    </div>
  );
}
```

---

## 실제 프로젝트에서의 State 관리

<LinkCard 
  title="React 상태관리 라이브러리들" 
  url="https://react.dev/learn/managing-state" 
  description="Redux, Zustand, Recoil 등 다양한 상태관리 솔루션 알아보기" 
/>

대규모 프로젝트에서는 컴포넌트 간 State 공유가 복잡해집니다. 이때 다음과 같은 솔루션을 고려할 수 있습니다:

1. **Context API**: React 내장 기능으로 전역 상태 관리
2. **Redux**: 예측 가능한 상태 컨테이너
3. **Zustand**: 간단하고 현대적인 상태 관리
4. **Recoil**: Facebook이 개발한 실험적 상태 관리

---

## 복습 퀴즈

퀴즈를 풀면서 State에 대한 이해도를 확인해봅시다!

<Quiz
 question="useState Hook의 반환값에 대한 설명으로 옳은 것은?"
 options={[
   "현재 상태값과 새로운 상태값을 반환한다",
   "현재 상태값과 상태 변경 함수를 배열로 반환한다", 
   "상태 변경 함수와 이전 상태값을 반환한다",
   "상태값만 반환하고 변경은 직접 해야 한다"
 ]}
 correctAnswer={1}
 explanation="useState는 [현재 상태값, 상태 변경 함수] 형태의 배열을 반환합니다. 구조분해할당을 통해 const [state, setState] = useState()와 같이 사용합니다."
/>

<Quiz
 question="State 업데이트와 관련하여 옳지 않은 것은?"
 options={[
   "setState는 비동기적으로 작동한다",
   "setState 호출 직후에는 이전 상태값을 가지고 있다",
   "setState 호출하면 컴포넌트가 즉시 동기적으로 리렌더링된다",
   "함수형 업데이트를 사용하면 최신 상태값을 기준으로 계산할 수 있다"
 ]}
 correctAnswer={2}
 explanation="setState는 비동기적으로 작동하며, React는 성능 최적화를 위해 여러 상태 업데이트를 배치(batch)로 처리합니다. 즉시 동기적으로 리렌더링되지 않습니다."
/>

<Quiz
 question="객체나 배열 State를 업데이트할 때 지켜야 할 원칙은?"
 options={[
   "기존 객체/배열을 직접 수정해도 된다",
   "불변성을 유지하며 새로운 객체/배열을 생성해야 한다",  
   "push, pop 등의 메서드를 자유롭게 사용할 수 있다",
   "setState 없이 직접 변수에 할당하면 된다"
 ]}
 correctAnswer={1}
 explanation="React는 State의 불변성을 기반으로 변경사항을 감지합니다. 객체나 배열을 직접 수정하면 React가 변화를 감지하지 못하므로, 스프레드 연산자(...) 등을 사용해 새로운 객체/배열을 생성해야 합니다."
/>

<Quiz
 question="여러 컴포넌트가 같은 State를 공유해야 할 때 사용하는 패턴은?"
 options={[
   "각 컴포넌트마다 동일한 State를 생성한다",
   "State를 가장 가까운 공통 부모 컴포넌트로 끌어올린다",
   "전역 변수를 사용한다",
   "localStorage에 저장해서 공유한다"
 ]}
 correctAnswer={1}
 explanation="여러 컴포넌트가 같은 State를 공유해야 할 때는 'State 끌어올리기(Lifting State Up)' 패턴을 사용합니다. 공통 부모 컴포넌트에서 State를 관리하고 Props로 자식들에게 전달합니다."
/>

<Quiz
 question="다음 중 State 성능 최적화 방법이 아닌 것은?"
 options={[
   "관련 없는 State들을 하나의 객체로 묶어서 관리한다",
   "필요에 따라 State를 여러 개로 분할한다",
   "useMemo를 사용해 비싼 계산을 메모이제이션한다", 
   "useCallback을 사용해 함수를 메모이제이션한다"
 ]}
 correctAnswer={0}
 explanation="관련 없는 State들을 하나의 객체로 묶으면 한 부분만 변경되어도 전체가 리렌더링되어 성능이 저하될 수 있습니다. 관련된 State끼리만 묶고, 독립적인 State는 분리하는 것이 좋습니다."
/>

---

## 마무리

<CalloutBox type="success" title="State 마스터 완료!">
축하합니다! React의 핵심 개념인 State를 완벽하게 이해하셨습니다. 

**학습한 내용:**
- State의 개념과 중요성
- useState Hook 사용법
- 다양한 타입의 State 관리
- State 업데이트 패턴과 주의사항
- 컴포넌트 간 State 공유 방법
- 실무에서 자주 사용하는 패턴들
- 성능 최적화 기법

이제 여러분은 React로 동적이고 인터랙티브한 웹 애플리케이션을 만들 수 있는 핵심 실력을 갖추었습니다!
</CalloutBox>

<Image
  src="/content/beginner/5/state-mastery.png"
  alt="State 마스터 완료"
  width="half"
  caption="React State, 이제 마스터했습니다!"
/>

State는 React 개발의 핵심입니다. 작은 카운터부터 복잡한 폼 관리까지, 모든 인터랙티브한 기능은 State에서 시작됩니다.

다음 단계에서는 컴포넌트 간의 데이터 전달 방법인 **Props**에 대해 자세히 알아보겠습니다. State와 Props를 함께 사용하면 더욱 강력하고 재사용 가능한 컴포넌트를 만들 수 있어요!

### 다음에 배울 내용 미리보기

- **Props**: 컴포넌트 간 데이터 전달의 모든 것
- **이벤트 처리**: 사용자 상호작용 다루기
- **조건부 렌더링**: 상황에 따라 다른 화면 보여주기
- **리스트 렌더링**: 배열 데이터를 화면에 표시하기

<LinkCard 
  title="React 공식 문서 - State 관리" 
  url="https://react.dev/learn/managing-state" 
  description="더 고급 State 관리 패턴과 베스트 프랙티스 알아보기" 
/>

---

**다음 강의에서 만나요!** React 여정의 다음 단계가 기대되시나요?