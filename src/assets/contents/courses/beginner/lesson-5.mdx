export const metadata = {
  id: 4,
  title: "컴포넌트",
  description: "React의 핵심인 컴포넌트가 무엇인지, 어떻게 만들고 사용하는지 벽돌틀 비유로 쉽게 알아봅시다.",
  difficulty: "쉬움",
  tags: ["React", "컴포넌트", "JSX", "props", "입문", "기초"],
  lastUpdated: "2025-07-27",
  image: "http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/5/5_thumb.png"
};

import { 
  CalloutBox, 
  ComparisonImages, 
  HighlightWord, 
  Quiz, 
  LinkCard,
  CodeSandbox,
  Image
} from '@/components/CourseContent/EmbeddedComponents'


<br/>
<ComparisonImages
  leftImage={{
    src: "http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/5/brick-mold.png",
    alt: "벽돌틀",
  }}
  rightImage={{
    src: "http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/5/brick-house.png",
    alt: "벽돌로 집 짓기",
  }}
  height={'lg'}
/>
<br/>
기계를 쓰는 요즘과 달리 과거에는 벽돌 하나를 찍어내기 위해 벽돌틀을 사용했습니다.

똑같은 모양의 벽돌을 만들기 위해 틀을 사용해 같은 모양의 여러 색상, 재질의 벽돌을 찍어냈죠.

이 벽돌들을 조합해서 집 전체를 만들어갑니다.

React의 컴포넌트도 마찬가지입니다.

<HighlightWord>여러번 재사용하며 UI를 그려낼 수 있는 코드들의 집합</HighlightWord>을 컴포넌트라고 부릅니다.

---

## 컴포넌트란? 재사용 가능한 UI 벽돌틀
<br/>
<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/5/component-example.png"
  alt="컴포넌트 개념 설명"
  width="full"
  caption="컴포넌트는 UI를 만드는 재사용 가능한 조각들입니다. 헤더나 갤러리 또한 재사용이 가능합니다."
/>
<br/>
React에서 <HighlightWord>컴포넌트(Component)</HighlightWord>는 UI를 구성하는 독립적이고 재사용 가능한 코드 조각입니다.

벽돌틀이 벽돌을 찍어내는 것처럼, 컴포넌트는 동일한 UI 요소를 반복해서 만들어낼 수 있는 "UI 틀"입니다.
<br/>
---
### 컴포넌트의 특징

- **재사용성**: 한 번 만들면 여러 곳에서 사용 가능
- **독립성**: 각각이 독립적으로 동작
- **조합성**: 작은 컴포넌트들을 조합해 큰 UI 구성

<br/>

집을 짓는 과정을 생각해보세요:
1. 벽돌틀로 벽돌을 만들고
2. 벽돌들로 벽을 쌓고
3. 벽들로 방을 만들고
4. 방들로 집을 완성합니다

React도 마찬가지입니다:
1. 작은 컴포넌트를 만들고
2. 컴포넌트들로 섹션을 만들고
3. 섹션들로 페이지를 만들고
4. 페이지들로 웹사이트를 완성합니다

---

## 컴포넌트 만들어보기

### 가장 간단한 컴포넌트

React 컴포넌트는 <HighlightWord>JSX를 반환하는 JavaScript 함수</HighlightWord>입니다.

<CodeSandbox
  code={`
function Welcome() {
  return <h1>안녕하세요!</h1>;
}

// 이 컴포넌트를 사용하는 App
function App() {
  return (
    <div>
      <Welcome />
      <Welcome />
      <Welcome />
    </div>
  );
}`}
  title="첫 번째 컴포넌트 만들기"
  language="jsx"
/>

Welcome이라는 Javascript 함수는 return문에서 JSX를 반환합니다.

이것이 React의 컴포넌트가 되고,

이를 똑같이 반복하여 호출하여 출력할 수 있습니다. 재사용한 것이죠.

<CalloutBox type="info" title="컴포넌트 규칙">
**이름은 대문자로 시작할 것**: `Welcome`, `Button`, `Header` (소문자는 HTML 태그로 인식)

JSX를 반환할 것: return 문에서 JSX를 반환해야 함

숫자로 시작 금지: 1Button ❌, Button1 ✅

특수문자 사용 금지: Button!, My-Button ❌, MyButton ✅

예약어 피하기: class, function, if 등은 컴포넌트 이름으로 사용 불가
</CalloutBox>

### 자주 재사용하는 버튼 컴포넌트

```js
function Button({ type = 'confirm', onClick, children }) {
 return (
   <button onClick={onClick}>
     {children}
   </button>
 );
}

function App() {
 return (
   <div>
   {/* type과 onClick 이벤트 함수를 prop으로 Button 컴포넌트에 넘겨주어 어떤 스타일과 형태를 띌지 결정합니다. */}
     <Button type="confirm" onClick={() => alert('확인!')}>
       확인
     </Button>
     
     <Button type="cancel" onClick={() => alert('취소!')}>
       취소
     </Button>
   </div>
 );
}
```

<CodeSandbox
  code={`
function Button({ type = 'confirm', onClick, children }) {
 return (
   <button 
     style={{
       backgroundColor: type === 'confirm' ? '#10b981' : '#6b7280',
       color: 'white',
       padding: '12px 24px',
       border: 'none',
       borderRadius: '8px',
       fontSize: '16px',
       cursor: 'pointer',
       margin: '0 8px'
     }}
     onClick={onClick}
   >
     {children}
   </button>
 );
}

function App() {
 return (
   <div style={{ padding: '20px' }}>

   {/* type과 onClick 이벤트 함수를 prop으로 Button 컴포넌트에 넘겨주어 어떤 스타일과 형태를 띌지 결정합니다. */}

     <Button 
       type="confirm" 
       onClick={() => alert('확인!')}
     >
       확인
     </Button>
     
     <Button 
       type="cancel" 
       onClick={() => alert('취소!')}
     >
       취소
     </Button>
   </div>
 );
}`}
  title="재사용 가능한 버튼 컴포넌트"
  language="jsx"
  hideCode={true}
/>

---

## Props: 컴포넌트에 정보 전달하기
<br/>
<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/5/props-component.png"
  alt="컴포넌트 Props 전달"
  width="two-thirds"
  caption="React에서 데이터는 단방향으로 흐르기에 부모 컴포넌트 -> 자식 컴포넌트로 데이터를 넘겨줄 수 있습니다."
/>
<br/>
벽돌틀에 다른 재료를 넣으면 다른 색깔의 벽돌이 나오는 것처럼, 컴포넌트에도 다른 정보를 전달할 수 있습니다.

이것을 <HighlightWord>Props(Properties)</HighlightWord>라고 합니다.

Props는 부모 컴포넌트가 자식 컴포넌트로 전달하는 <HighlightWord>읽기 전용 데이터</HighlightWord>에 가깝습니다.

자식 컴포넌트에서는 부모로부터 받은 props 데이터를 읽어서 활용하는 데에 그치죠.

자식 컴포넌트에서 이 값을 수정하려거나 조작하려면 React의 데이터 단방향 흐름을 바꾸는 다른 방법들을 사용해야합니다. 

이 방법은 이후 뒷회차에서 차근히 살펴보도록 하겠습니다.

Props로 넘길 때는 객체 전체를 spread하여 ```<Button {...data}/> ```의 형태로 객체 자체를 넘길수도 있고,

각각의 값을 명시적으로 ``` <Button text={"Hello"} color={"red"} /> ```처럼 전달할 수도 있습니다.
<br/>

```js
{/* Props를 받는 컴포넌트 */}
function Greeting(props) {
  return <h2>안녕하세요, {props.name}님!</h2>;
}

{/* 구조분해할당으로 더 깔끔하게 Prop들을 컴포넌트 내에서 사용할 수 있습니다 */}
function UserCard({ name, age, hobby }) {
  return (
    <div>
      <h3>{name}</h3>
      <p>나이: {age}세</p>
      <p>취미: {hobby}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <Greeting name="철수" />
      <Greeting name="영희" />
      
      <UserCard name="김철수" age={25} hobby="게임" />
      <UserCard name="이영희" age={30} hobby="독서" />
      <UserCard name="박민수" age={28} hobby="요리" />
    </div>
  );
}
```
<CodeSandbox
  code={`
  {/* Props를 받는 컴포넌트 */}
function Greeting(props) {
  return <h2>안녕하세요, {props.name}님!</h2>;
}

{/* 구조분해할당으로 더 깔끔하게 Prop들을 컴포넌트 내에서 사용할 수 있습니다 */}
function UserCard({ name, age, hobby }) {
  return (
    <div style={{
      border: '2px solid #e5e7eb',
      borderRadius: '12px',
      padding: '20px',
      margin: '10px',
      backgroundColor: '#f9fafb'
    }}>
      <h3>{name}</h3>
      <p>나이: {age}세</p>
      <p>취미: {hobby}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <Greeting name="철수" />
      <Greeting name="영희" />
      
      <UserCard name="김철수" age={25} hobby="게임" />
      <UserCard name="이영희" age={30} hobby="독서" />
      <UserCard name="박민수" age={28} hobby="요리" />
    </div>
  );
}`}
  title="Props로 데이터 전달하기"
  language="jsx"
  hideCode={true}
/>

<br/>
---

## 컴포넌트 합성: 벽돌이 벽으로, 벽이 건물로
<br/>
작은 컴포넌트들을 조합해서 더 큰 컴포넌트를 만드는 것을 <HighlightWord>컴포넌트 합성(Component Composition)</HighlightWord>이라고 합니다.

React 앱에는 컴포넌트가 큰 컴포넌트를 이루고, 큰 컴포넌트들이 페이지를 이루어 애플리케이션을 완성합니다.
```js
{/* 작은 컴포넌트들 - 이 3개의 컴포넌트를 조합해 UserCard라는 큰 컴포넌트를 구성합니다. */}
function Avatar({ src, name }) {
 return (
   <img 
     src={src} 
     alt={name}
   />
 );
}

function UserName({ name }) {
 return <h3>{name}</h3>;
}

function UserEmail({ email }) {
 return <p>{email}</p>;
}

// 큰 컴포넌트: 작은 컴포넌트들을 조합
function UserCard({ user }) {
 return (
   <div>
     <Avatar src={user.avatar} name={user.name} />
     <div>
       <UserName name={user.name} />
       <UserEmail email={user.email} />
     </div>
   </div>
 );
}

function App() {
 const user = {
   name: '김철수',
   email: 'kim@example.com',
   avatar: 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=100&h=100&fit=crop&crop=face'
 };

 return (
   <div>
     <UserCard user={user} />
   </div>
 );
```
<CodeSandbox
  code={`
function Avatar({ src, name }) {
 return (
   <img 
     src={src} 
     alt={name}
     style={{
       width: '50px',
       height: '50px',
       borderRadius: '50%'
     }}
   />
 );
}

function UserName({ name }) {
 return <h3 style={{ margin: '0 0 5px 0' }}>{name}</h3>;
}

function UserEmail({ email }) {
 return <p style={{ margin: 0, color: '#666' }}>{email}</p>;
}

function UserCard({ user }) {
 return (
   <div style={{
     display: 'flex',
     alignItems: 'center',
     gap: '15px',
     padding: '20px',
     border: '1px solid #ddd',
     borderRadius: '8px'
   }}>
     <Avatar src={user.avatar} name={user.name} />
     <div>
       <UserName name={user.name} />
       <UserEmail email={user.email} />
     </div>
   </div>
 );
}

function App() {
 const user = {
   name: '김철수',
   email: 'kim@example.com',
   avatar: 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=100&h=100&fit=crop&crop=face'
 };

 return (
   <div style={{ padding: '20px' }}>
     <UserCard user={user} />
   </div>
 );
}`}
  title="컴포넌트 합성 예제 - 프로필 카드"
  language="jsx"
  hideCode={true}
/>

<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/5/component-tree.png"
  alt="컴포넌트 계층 구조"
  width="two-thirds"
  caption="작은 컴포넌트들이 모여 큰 컴포넌트를 만드는 계층 구조"
/>

---

## 조건부 렌더링: 상황에 따라 다른 벽돌 선택하기

때로는 상황에 따라 다른 UI를 보여줘야 합니다. 이를 <HighlightWord>조건부 렌더링</HighlightWord>이라고 합니다.

<CodeSandbox
  code={`
function Status({ isOnline }) {
 return (
   <div style={{ padding: '20px', textAlign: 'center' }}>
     {isOnline ? (
       <div style={{ color: 'green' }}>
         <h2>🟢 온라인</h2>
         <p>사용자가 접속 중입니다</p>
       </div>
     ) : (
       <div style={{ color: 'red' }}>
         <h2>🔴 오프라인</h2>
         <p>사용자가 접속하지 않았습니다</p>
       </div>
     )}
   </div>
 );
}

function App() {
 return (
   <div>
     <Status isOnline={true} />
     <Status isOnline={false} />
   </div>
 );
}`}
  title="조건부 렌더링 예제"
  language="jsx"
/>
위의 예제에서는 같은 컴포넌트를 재사용하지만 조건에 따라 다른 UI를 보여줍니다.

때에 아래처럼 따라서는 변수나, state에 따라 컴포넌트 자체를 조건부 렌더링할 수도 있습니다.
```js
    {
        isOnline ?? <Status />
    }
```
<br/>
---

## 리스트 렌더링: 벽돌을 줄지어 배치하기

같은 형태의 컴포넌트를 여러 개 반복해서 렌더링할 때는 <HighlightWord>리스트 렌더링</HighlightWord>을 사용합니다.

<CodeSandbox
  code={`
function TodoItem({ todo }) {
    return (
    <div style={{
        padding: '10px',
        margin: '5px 0',
        backgroundColor: '#f0f0f0',
        borderRadius: '5px'
    }}>
        {todo}
    </div>
    );
    }

function App() {
    const todos = [
    'React 공부하기',
    '컴포넌트 만들기',
    '프로젝트 완성하기'
    ];

    return (
    <div style={{ padding: '20px' }}>
        <h2>할 일 목록</h2>
        {todos.map((todo, index) => (
        <TodoItem key={index} todo={todo} />
        ))}
    </div>
    );
}`}
  title="리스트 렌더링 예제"
  language="jsx"
/>

주로 list를 다룰 때 순회하는 map을 사용하여 컴포넌트를 반복 렌더링합니다.

반복 렌더링을 할 때는 key prop을 자식 컴포넌트에 선언하지 않아도 속성과 같이 부여할 수 있습니다.

반복 렌더링된 컴포넌트는 key를 부여해야 서로 독립적인 컴포넌트로 동작할 수 있습니다.

<CalloutBox type="warning" title="Key Prop 주의사항">
**key prop은 필수**: 리스트를 렌더링할 때는 각 아이템에 고유한 `key` prop을 제공해야 합니다.

**고유값 사용**: 보통 데이터의 `id` 값을 사용하며, 배열의 인덱스는 가급적 피해주세요.
중복되거나 방해되는 값이 발생하면 오류가 발생합니다.

**성능 최적화**: React가 어떤 아이템이 변경되었는지 key값을 통해서 효율적으로 파악할 수 있게 해줍니다.
</CalloutBox>
<br/>
---
<br/>
## 컴포넌트 설계 원칙

좋은 컴포넌트를 만들기 위한 원칙들을 알아봅시다.
<br/>
### 1. 단일 책임 원칙

각 컴포넌트는 하나의 명확한 역할을 가져야 합니다.

```js
// 권장하지 않는 설계 예시 - 너무 많은 역할을 하는 하나의 컴포넌트
const BadComponent = () => {
  const [name, setName] = useState('김개발');
  const [email, setEmail] = useState('kim@example.com');
  const [posts, setPosts] = useState(['글1', '글2']);
  const [theme, setTheme] = useState('light');

  return (
    <div className={theme === 'dark' ? 'bg-gray-800 text-white p-4' : 'bg-white p-4'}>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        테마 변경
      </button>
      <h2>{name}</h2>
      <p>{email}</p>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <div>
        {posts.map((post, i) => <div key={i}>{post}</div>)}
      </div>
    </div>
  );
};
```
<br/>
하나의 컴포넌트에 너무 많은 기능과 역할을 부여하면 어떻게 될까요?

나중에 유지보수할 때 특정 기능을 수정하게 되면, 

이 컴포넌트를 재사용하는 다른 페이지나 컴포넌트에서 예상치 못한 문제가 발생할 수 있습니다.
<br/>
벽돌을 하나하나 쌓는 대신 귀찮다고 여러 벽돌을 통째로 뭉쳐서 큰 덩어리로 만들었다고 가정해봅시다. 

이 벽 덩어리를 거실에 설치하고, 나중에 화장실에도 똑같은 벽을 재사용했습니다.

그런데 거실을 리모델링한다고 미지의 힘으로 거실에 맞게 벽을 수정해버리면 어떻게 될까요?

화장실의 벽도 동시에 바뀌어버려서 대참사가 일어나겠죠?
<br/>
컴포넌트도 마찬가지입니다. 

너무 많은 기능을 하나에 몰아넣으면 한 곳을 고쳤을 때 다른 곳에서 문제가 생길 수 있어요.

좋은 설계 예시를 살펴볼게요.
<br/>
```js
 // 권장 설계 예시 - 각각이 명확한 역할을 가진 컴포넌트들
  // 1. 사용자 정보
const UserCard = ({ name, email, onNameChange }) => (
  <div className="border p-2">
    <h2>{name}</h2>
    <p>{email}</p>
    <input value={name} onChange={(e) => onNameChange(e.target.value)} />
  </div>
);

// 2. 게시글
const Posts = ({ posts }) => (
  <div>
    {posts.map((post, i) => <div key={i} className="border p-1">{post}</div>)}
  </div>
);

// 3. 테마 버튼
const ThemeButton = ({ theme, onToggle }) => (
  <button onClick={onToggle} className="bg-blue-500 text-white px-2 py-1">
    {theme === 'light' ? '다크' : '라이트'}
  </button>
);

// 4. 위의 모든 컴포넌트 조합
const GoodComponent = () => {
  const [name, setName] = useState('김개발');
  const [posts] = useState(['글1', '글2']);
  const [theme, setTheme] = useState('light');

  return (
    <div className={theme === 'dark' ? 'bg-gray-800 text-white p-4' : 'bg-white p-4'}>
      <ThemeButton theme={theme} onToggle={() => setTheme(theme === 'light' ? 'dark' : 'light')} />
      <UserCard name={name} email="kim@example.com" onNameChange={setName} />
      <Posts posts={posts} />
    </div>
  );
};
```
<br/>
이렇게 설계해놓으면 수정이 필요한 부분만 따로 수정이 가능하니까,

나중을 생각했을 때 많이 편리하겠죠?

<br/>

### 2. Props는 최소한으로

너무 많은 props를 받는 컴포넌트는 복잡해집니다.

```jsx
// ❌ 너무 많은 props
function UserProfile({ 
  name, age, email, phone, address, company, 
  role, department, salary, hireDate, manager 
}) {
  // ...
}

// ✅ 객체로 그룹화
function UserProfile({ personalInfo, workInfo }) {
  // 컴포넌트 내부에서 구조분해할당 활용
  const { name, age, email } = personalInfo;
  const { company, role, department } = workInfo;
  
  return (
    <div>
      <h2>{name} ({age}세)</h2>
      <p>이메일: {email}</p>
      <p>회사: {company}</p>
      <p>직책: {role}</p>
    </div>
  );
}

// 사용할 때는 spread 연산자로 간편하게
function App() {
  const userData = {
    personalInfo: { name: '김철수', age: 30, email: 'kim@example.com' },
    workInfo: { company: '테크회사', role: '개발자', department: 'IT팀' }
  };

  return <UserProfile {...userData} />;
}
```
<br/>
객체를 spread 연산자를 통해 직접 전달할 수 있습니다.

보기에도 간결하고 다른 컴포넌트에 전달할 때도 간단하게 전달할 수 있겠네요.

또한 객체를 전달받은 자식 컴포넌트에서 구조분해할당을 활용해 사용할 때 편하고 가시성있게 설계를 할 수 있습니다.
<br/>
### 3. 컴포넌트는 작게, 조합은 크게

<CalloutBox type="success" title="컴포넌트 설계 팁">
**작은 벽돌**: 각 컴포넌트는 작고 집중된 기능을 가지세요

**큰 건물**: 작은 컴포넌트들을 조합해서 점점 큰 기능을 만드세요

**재사용성**: 다른 곳에서도 쓸 수 있도록 유연하게 컴포넌트를 작성하세요

 **명확한 이름**: 컴포넌트 이름만 딱 봐도 역할을 알 수 있게끔 작명하세요
</CalloutBox>

---

## 복습 퀴즈

<Quiz
 question="React 컴포넌트의 이름 규칙으로 올바른 것은?"
 options={[
   "소문자로 시작해야 한다 (button)",
   "대문자로 시작해야 한다 (Button)",
   "숫자로 시작해도 된다 (1Button)",
   "특수문자를 포함해도 된다 (Button!)"
 ]}
 correctAnswer={1}
 explanation="React 컴포넌트 이름은 반드시 대문자로 시작해야 합니다. 소문자로 시작하면 HTML 태그로 인식됩니다."
/>

<Quiz
 question="props에 대한 설명으로 틀린 것은?"
 options={[
   "부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 방법이다",
   "props는 컴포넌트 내부에서 직접 수정할 수 있다",
   "같은 컴포넌트에 다른 props를 전달해서 다른 UI를 만들 수 있다",
   "구조분해할당을 사용해서 props를 받을 수 있다"
 ]}
 correctAnswer={1}
 explanation="props는 읽기 전용(read-only)입니다. 컴포넌트 내부에서 props를 직접 수정할 수 없으며, 새로운 props를 전달받아야 UI가 변경됩니다."
/>

<Quiz
 question="리스트 렌더링에서 key prop이 필요한 이유는?"
 options={[
   "컴포넌트의 이름을 지정하기 위해",
   "React가 어떤 아이템이 변경되었는지 효율적으로 파악하기 위해",
   "컴포넌트에 스타일을 적용하기 위해",
   "데이터베이스와 연결하기 위해"
 ]}
 correctAnswer={1}
 explanation="key prop은 React가 가상 DOM을 효율적으로 업데이트하기 위해 필요합니다. 어떤 아이템이 추가, 수정, 삭제되었는지 빠르게 파악할 수 있게 해줍니다."
/>

<Quiz
 question="컴포넌트 합성에 대한 설명으로 올바른 것은?"
 options={[
   "하나의 컴포넌트에 모든 기능을 넣는 것",
   "작은 컴포넌트들을 조합해서 더 큰 컴포넌트를 만드는 것",
   "컴포넌트를 복사해서 사용하는 것",
   "컴포넌트의 이름을 합치는 것"
 ]}
 correctAnswer={1}
 explanation="컴포넌트 합성은 작은, 재사용 가능한 컴포넌트들을 조합해서 더 복잡한 UI를 만드는 React의 핵심 패턴입니다."
/>

---

## 참고 사항

<LinkCard 
  title="ReactJS Docs - React.Component 문서" 
  url="https://ko.legacy.reactjs.org/docs/react-component.html" 
  description="이 문서에서는 React 컴포넌트 class를 다루는 API들을 자세히 소개합니다. 해당 내용에 대해 더 자세히 학습해보세요." 
/>

<CalloutBox type="success" title="🎉 축하합니다!">
React 컴포넌트의 핵심을 학습했습니다! 이제 재사용 가능한 UI 조각들을 만들고 조합할 수 있습니다. <br/>

다음에는 React의 State, 상태에 대해 알아보겠습니다.
</CalloutBox>