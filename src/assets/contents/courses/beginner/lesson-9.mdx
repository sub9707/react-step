export const metadata = {
  id: 8,
  title: "데이터 가져오기 - useEffect와 함께하는 API 통신",
  description: "React에서 외부 데이터를 가져오고 관리하는 방법을 useEffect Hook을 중심으로 학습합니다.",
  difficulty: "보통",
  tags: ["React", "useEffect", "API", "데이터 페칭", "비동기", "HTTP", "입문"],
  lastUpdated: "2025-08-05",
  image: "http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/9/lesson-8-bg.png"
};

import { 
  CalloutBox, 
  ComparisonImages, 
  HighlightWord, 
  Quiz, 
  LinkCard,
  CodeSandbox,
  Image
} from '@/components/CourseContent/EmbeddedComponents'

<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/9/lesson-8-intro.gif"
  alt="데이터 흐름"
  width="two-thirds"
  caption="웹 애플리케이션에서 서버로부터 데이터를 가져와 화면에 표시 예) PokeAPI"
  isGif={true}
/>
<br/>
지금까지 우리는 컴포넌트 내부에서 useState로 관리하는 정적인 데이터들을 다뤄왔습니다.

하지만 실제 웹 애플리케이션에서는 <HighlightWord>서버에서 실시간으로 데이터를 가져와 화면에 표시</HighlightWord>해야 하는 경우가 대부분입니다.

사용자 정보, 상품 목록, 댓글, 게시글 등 대부분의 데이터는 외부 서버에 저장되어 있고, 필요할 때마다 가져와서 사용해야 합니다.

React에서는 이런 외부 데이터를 어떻게 가져오고 관리할까요?

---

## useEffect Hook 소개
지난번 React의 생명주기를 알아볼 때 함수형 컴포넌트에서 useEffect 훅을 사용한다고 알아봤죠?

<HighlightWord>useEffect</HighlightWord>는 React의 핵심 Hook 중 하나로, <HighlightWord>컴포넌트가 렌더링된 후에 특정 작업을 수행</HighlightWord>할 때 사용합니다.

주로 다음과 같은 상황에서 생명주기에 맞게 사용됩니다

<CalloutBox type="info" title="useEffect의 주요 용도">
**데이터 가져오기**: API 호출, 서버 통신

**구독 설정**: 웹소켓, 이벤트 리스너 등록

**타이머 설정**: setInterval, setTimeout

**DOM 조작**: 직접적인 DOM 접근이 필요한 경우

**정리 작업**: 컴포넌트가 사라질 때 리소스 해제
</CalloutBox>

### useEffect의 기본 문법

```js
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // 컴포넌트가 렌더링된 후 실행될 코드
    console.log('컴포넌트가 렌더링되었습니다!');
  });

  return <div>Hello World</div>;
}
```
자, 자세히 살펴볼까요?

우선 useEffect의 기본 형태는 아래와 같이 생겼습니다.

```js
import { useEffect } from 'react';

useEffect();
```
react에서 제공하는 함수 형태입니다.

```js
import { useEffect } from 'react';

useEffect(()=>{});
```

여기에 첫번째 인자로 화살표 함수, 즉 또다른 콜백 함수를 전달하네요.

이렇게되면, react 컴포넌트는 렌더링된 바로 직후에 이 코드를 실행시킵니다.

return문 뒤의 JSX를 가상 DOM과 실제 DOM에 적용한 뒤 화면이 그려진 후에야 useEffect 내부의 콜백이 실행되는거예요.

<br/>

여기서, useEffect 함수의 <HighlightWord>두번째 인자</HighlightWord>로 빈배열을 넘겨준다면 어떻게 될까요?

---

## 의존성 배열(Dependency Array)

useEffect는 두 번째 인자로 <HighlightWord>의존성 배열</HighlightWord>을 받을 수 있습니다. 이 배열은 useEffect가 <HighlightWord>언제 실행될지를 결정</HighlightWord>합니다.

이 배열에 요소를 넣으면 <HighlightWord>"이 요소가 바뀔 때만 useEffect를 수행하겠다"</HighlightWord>는 의미입니다.

### 1. 의존성 배열 없음 - 매번 실행

```js
useEffect(() => {
  console.log('렌더링할 때마다 실행');
});
```

### 2. 빈 배열 - 최초 한 번만 실행

```js
useEffect(() => {
  console.log('컴포넌트가 처음 마운트될 때만 실행');
}, []);
```

### 3. 특정 값들 - 해당 값이 변경될 때만 실행

```js
useEffect(() => {
  console.log('count가 변경될 때마다 실행');
}, [count]);
```

형태를 보면, 의존성 배열을 전달하지 않은 useEffect는 컴포넌트를 처음 렌더링할 때 마다 계속 실행합니다.

의존성 배열을 전달하지 않으니 제약된 것이 없기에 무조건 수행하는 식입니다.
<br/>
빈 배열을 전달한다면 어떨까요.

빈 배열을 전달하면 컴포넌트가 처음 렌더링 됐을 때 초기에 한번 수행합니다.

그러나 의존성 배열을 암만 뒤져보아도 바꿀 요소가 없기에 그 다음 렌더링부터는 수행할 필요가 없다고 미리 알려줍니다.
<br/>
배열에 요소를 넣으면 이 요소가 변할 때마다 useEffect는 마침내 수행됩니다.

값이 그대로면 렌더링하고도 수행되지 않아요.

---

## 데이터 가져오기의 기본 패턴

실제 API에서 데이터를 가져오는 기본적인 패턴을 살펴보겠습니다.

```js
import { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    // 비동기 함수로 데이터 가져오기
    const fetchUsers = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        const userData = await response.json();
        setUsers(userData);
      } catch (error) {
        console.error('데이터 가져오기 실패:', error);
      }
    };

    fetchUsers();
  }, []); // 빈 배열로 최초 한 번만 실행


  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

보통의 웹에서 유저 정보를 처음 한 번 가져오고 그 데이터를 토대로 화면을 구성하는 방식입니다.

유저 정보는 실시간으로 계속 변하도록 기획하지 않는 이상, 처음 한 번만 받아오고 화면에 그려냅니다.

<HighlightWord>처음 한 번</HighlightWord> 한꺼번에 데이터를 받고 이를 사용하면 되겠죠?

<HighlightWord>처음 한 번</HighlightWord>에 어울리는 useEffect 구성 방식은 <HighlightWord>의존성 배열이 빈 형태</HighlightWord>입니다.

위와 같이 구성하면 페이지에 접속하고, UserList 컴포넌트가 처음 렌더링되고나면 그 때 수행됩니다.

---

## 로딩 상태와 에러 처리

실제 애플리케이션에서는 데이터를 가져오는 동안의 로딩 상태와 에러 상황을 적절히 처리해야 합니다.

최신 React에서 활동 상태, 그러니까 데이터를 가져오면서 진행중인 상태에 대해 더 효율적이고 가독성 높은 방식을 제공하고,

이와 비슷한 기능을 제공하는 다수의 라이브러리들도 존재하지만,

초급 과정에서는 useState와 useEffect로만 단순하게 이 로딩, 에러 상태들을 출력하고 

상황에 맞게 UI를 구성하는 전통적인 패턴을 살펴보겠습니다.
<br/>

### 기본 데이터 페칭 패턴

```js
function DataComponent() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch('/api/data');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!data) return <NoData />;

  return <DataDisplay data={data} />;
}
```

자 코드를 하나씩 살펴봅시다.

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```
먼저, 

data → 서버에서 받아올 실제 데이터를 state로 기억합니다.

loading → "지금 데이터를 불러오는 중인지"를 나타내는 boolean 값입니다.

error → 에러가 생겼을 때 메시지라던가, 기억해야하는 상태 등을 나타냅니다.

이렇게 상태를 나누면 상황별로 UI를 다르게 보여줄 수 있습니다.

<br/>

그 아래 fetchData 함수를 봅시다.

```setLoading(true)```로 데이터 가져오기 시작 전, 로딩 상태를 true로 변경합니다.

로딩 중에 어떤 UI로 화면을 구성하는지 선택할 수 있게됩니다.
<br/>
```<LoadingSpinner />``` 같은 로딩 스피너라든지 로딩 중 보일 UI를 설정할 수 있죠.
<br/>
```setError(null)```  이전 요청에서 에러가 있었을 수 있으니, 에러 상태를 초기화해줍니다.
<br/>
```fetch('/api/data')```로 /api/data 주소로 GET 요청을 보냅니다.
<br/>
응답이 ok가 아니면(404, 500 같은 상태) ```throw new Error()```로 강제로 에러를 발생시킵니다.
<br/>
```await response.json()```에서는 응답을 JSON 형식으로 변환 후 data 상태에 저장합니다.


성공하면 data 상태에 결과를 저장하고, 실패하면 아래 에러 처리를 따릅니다.
<br/>
이 과정이 모두 완료되면 로딩 중 상태를 해제하고 결과를 보여주게 되는 것입니다.

---

## useEffect 정리(Cleanup) 함수

useEffect에서 설정한 구독이나 타이머 등은 컴포넌트가 사라질 때 정리해줘야 합니다. 

제대로 정리해주지 않으면 컴포넌트가 화면에서 사라졌는데도 계속 타이머나 구독 기능이 돌아가면서 메모리와 CPU가 누수되는 현상이 발생합니다.

이를 위해 useEffect의 return을 말미에 넣어 <HighlightWord>정리 함수(cleanup function)</HighlightWord>로 사용합니다.

```js
useEffect(() => {
  // 설정 작업
  const timer = setInterval(() => {
    console.log('타이머 실행');
  }, 1000);

  // 정리 함수 반환
  return () => {
    clearInterval(timer);
    console.log('타이머 정리됨');
  };
}, []);
```

---

## 조건부 데이터 가져오기

때로는 특정 조건이 만족될 때만 데이터를 가져와야 합니다. 예를 들어, 사용자 ID가 있을 때만 사용자 정보를 가져오는 경우입니다.

요소가 변할때마다 콜백 함수를 수행하는 <HighlightWord>의존성 배열을 추가한 useEffect</HighlightWord>를 활용하면 되겠죠.

```js
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // userId가 없으면 데이터를 가져오지 않음
    if (!userId) {
      setUser(null);
      return;
    }

    const fetchUser = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('사용자 데이터 로드 실패:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]); // userId가 변경될 때마다 실행

  if (!userId) return <div>사용자를 선택해주세요</div>;
  if (loading) return <div>로딩중...</div>;
  if (!user) return <div>사용자를 찾을 수 없습니다</div>;

  return <div>{user.name}</div>;
}
```

이렇게 되면 페이지 사용 도중 로그아웃을 한다거나, 유효시간이 끝나 유저 정보가 변하게 되면

페이지의 접근을 막거나 특정 컴포넌트의 표시를 제한할 수 있습니다.

---

## 커스텀 Hook으로 데이터 페칭 로직 재사용하기

데이터 페칭 로직을 커스텀 Hook으로 분리하면 여러 컴포넌트에서 재사용할 수 있습니다.

또한 코드 분량이 줄어드니 코드 가독성이 높아지고 나중에 유지보수를 하게될 때 유용하죠.

```js
// 커스텀 Hook
// 보통 src/hooks 폴더에 useFetch.js 와 같이 분리하고 이를 import하는 방식으로 많이 사용합니다.
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('데이터 가져오기 실패');
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    if (url) {
      fetchData();
    }
  }, [url]);

  return { data, loading, error };
}

// 사용 컴포넌트
function PostList() {
  // 커스텀 훅에서 정의한 요소만 쏙 가져올 수 있습니다.
  const { data: posts, loading, error } = useFetch('/api/posts');

  if (loading) return <div>로딩중...</div>;
  if (error) return <div>에러: {error}</div>;

  return (
    <ul>
      {posts?.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```
---

## 성능 최적화 팁

<CalloutBox type="success" title="데이터 페칭 성능 최적화">
**적절한 의존성 배열 사용**: 불필요한 재실행 방지

**요청 취소**: AbortController로 불필요한 요청 취소

**캐싱 활용**: 같은 데이터를 반복 요청하지 않기

**로딩 상태 관리**: 사용자 경험 향상을 위한 적절한 로딩 UI

**에러 처리**: 네트워크 오류에 대한 적절한 대응

**메모리 누수 방지**: 언마운트된 컴포넌트에서 상태 업데이트 방지
</CalloutBox>

---

## 실제 프로젝트에서 사용하는 라이브러리들

실제 프로젝트에서는 더 강력한 데이터 페칭 라이브러리들을 사용하는 경우가 많습니다:

<ImageGallery
  images={[
    { src: 'http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/9/react-query.png', alt: 'react-query' },
    { src: 'http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/9/SWR.jpg', alt: 'SWR' },
    { src: 'http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/9/apollo.png', alt: 'apollo' },
    { src: 'http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/9/axios.png', alt: 'axios' },
  ]}
/>

<LinkCard 
  title="React Query (TanStack Query)" 
  url="https://tanstack.com/query/latest" 
  description="가장 인기 있는 React 데이터 페칭 라이브러리, 강력한 캐싱과 동기화 기능 지원" 
/>
<LinkCard 
  title="SWR" 
  url="https://tanstack.com/query/latest" 
  description="간단하고 가벼운 데이터 페칭" 
/>
<LinkCard 
  title="Apollo Client" 
  url="https://tanstack.com/query/latest" 
  description="GraphQL을 위한 완전한 솔루션" 
/>
<LinkCard 
  title="Axios" 
  url="https://tanstack.com/query/latest" 
  description="HTTP 클라이언트 라이브러리" 
/>

---

## 복습 퀴즈

<Quiz
 question="useEffect의 의존성 배열에 대한 설명으로 옳은 것은?"
 options={[
   "의존성 배열이 없으면 컴포넌트가 처음 마운트될 때만 실행된다",
   "빈 배열 []을 전달하면 매번 렌더링될 때마다 실행된다",
   "빈 배열 []을 전달하면 컴포넌트가 처음 마운트될 때만 실행된다",
   "의존성 배열의 값과 상관없이 항상 매번 실행된다"
 ]}
 correctAnswer={2}
 explanation="빈 배열 []을 의존성 배열로 전달하면 useEffect는 컴포넌트가 처음 마운트될 때만 한 번 실행됩니다. 의존성 배열이 없으면 매번 렌더링할 때마다 실행되고, 배열에 값이 있으면 해당 값이 변경될 때마다 실행됩니다."
/>

<Quiz
 question="데이터 페칭 시 로딩 상태를 관리하는 이유가 아닌 것은?"
 options={[
   "사용자에게 현재 상태를 알려주기 위해",
   "네트워크 요청 중 사용자 경험을 향상시키기 위해",
   "서버의 응답 속도를 빠르게 하기 위해",
   "중복 요청을 방지하기 위해"
 ]}
 correctAnswer={2}
 explanation="로딩 상태 관리는 클라이언트 측에서 사용자 경험을 개선하는 것이며, 서버의 응답 속도 자체를 빠르게 하지는 않습니다. 로딩 상태는 사용자에게 현재 진행 상황을 알리고, 중복 요청을 방지하는 데 사용됩니다."
/>

<Quiz
 question="useEffect에서 정리 함수(cleanup function)가 필요한 경우는?"
 options={[
   "데이터를 처음 가져올 때",
   "상태값을 업데이트할 때",
   "타이머나 구독을 설정했을 때",
   "컴포넌트가 처음 렌더링될 때"
 ]}
 correctAnswer={2}
 explanation="정리 함수는 setInterval, setTimeout, 이벤트 리스너, 웹소켓 연결 등을 설정했을 때 컴포넌트가 언마운트되거나 의존성이 변경될 때 이들을 정리하기 위해 필요합니다. 메모리 누수나 불필요한 작업을 방지하는 중요한 역할을 합니다."
/>

<Quiz
 question="커스텀 Hook을 사용하는 주된 이유는?"
 options={[
   "성능을 향상시키기 위해",
   "코드의 재사용성을 높이기 위해",
   "메모리 사용량을 줄이기 위해",
   "렌더링 속도를 빠르게 하기 위해"
 ]}
 correctAnswer={1}
 explanation="커스텀 Hook의 주된 목적은 상태 로직을 재사용 가능한 함수로 분리하여 여러 컴포넌트에서 동일한 로직을 재사용할 수 있게 하는 것입니다. 이를 통해 코드 중복을 줄이고 유지보수성을 향상시킬 수 있습니다."
/>

---

## 참고 자료

<LinkCard 
  title="React 공식 문서 - useEffect" 
  url="https://react.dev/reference/react/useEffect" 
  description="useEffect Hook에 대한 상세한 공식 문서" 
/>

<LinkCard 
  title="MDN - Fetch API" 
  url="https://developer.mozilla.org/ko/docs/Web/API/Fetch_API" 
  description="웹 API에서 데이터를 가져오는 Fetch API 가이드" 
/>

---

<CalloutBox type="success" title="🎉 축하합니다!">
React에서 useEffect를 원하는 상황에 활용하고 데이터를 가져오는 방식에 대해 학습했습니다.
</CalloutBox>