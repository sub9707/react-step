export const metadata = {
  id: 9,
  title: "JSX와 기본 문법",
  description: "React가 화면을 구성하는 기본 단위인 JSX와 그와 관련된 기본 문법을 알아봅니다.",
  difficulty: "쉬움",
  tags: ["React", "JSX", "className", "React Fragment", "이벤트", "입문"],
  lastUpdated: "2025-08-15",
  image: "/content/beginner/4/lesson-4-bg.png"
};

import { 
  CalloutBox, 
  ComparisonImages, 
  HighlightWord, 
  Quiz, 
  LinkCard,
  CodeSandbox,
  Image
} from '@/components/CourseContent/EmbeddedComponents'

<Image
  src="/content/beginner/4/JSX.png"
  alt="JSX 예시"
  width="half"
/>
<br/>
React를 배우다 보면 <HighlightWord>JSX</HighlightWord>라는 용어를 자주 접하게 됩니다.

JSX는 React의 가장 기본적이면서도 중요한 개념 중 하나입니다.

HTML과 JavaScript를 하나로 합쳐놓은 것 같은 이 문법이 처음에는 어색할 수 있지만, 한번 익숙해지면 매우 직관적이고 편리합니다.

---

## JSX란 무엇인가요?

<HighlightWord>JSX(JavaScript XML)</HighlightWord>는 JavaScript 코드 안에서 HTML과 비슷한 마크업을 작성할 수 있게 해주는 문법 확장입니다.

일반적인 HTML과 거의 똑같이 생겼지만, JavaScript의 모든 기능을 함께 사용할 수 있습니다.

```jsx
// JSX 예시
const element = <h1>안녕하세요, React!</h1>;

// 일반 JavaScript로 같은 결과를 만들려면
const element = React.createElement('h1', null, '안녕하세요, React!');
```

위의 두 코드는 완전히 같은 결과를 만들어냅니다. 

JSX가 얼마나 간편한지 알 수 있죠?

<CalloutBox type="info" title="JSX의 특징">
**HTML과 비슷함**: 기존에 HTML을 알고 있다면 쉽게 익힐 수 있습니다

**JavaScript 통합**: 중괄호 {}를 사용해 HTML 내부에서 JavaScript 표현식을 바로 사용할 수 있습니다

**컴포넌트 친화적**: React 컴포넌트를 마치 HTML 태그처럼 사용할 수 있습니다
</CalloutBox>

---

## JSX 기본 문법

### 1. JavaScript 표현식 삽입

JSX에서는 중괄호 `{}`를 사용해서 JavaScript 표현식을 삽입할 수 있습니다.

```jsx
function App() {
  const name = '김리액트';
  const age = 25;
  const isStudent = true;

  return (
    <div>
      <h1>안녕하세요, {name}님!</h1>
      <p>나이: {age}세</p>
      <p>학생 여부: {isStudent ? '학생입니다' : '학생이 아닙니다'}</p>
      <p>내년 나이: {age + 1}세</p>
    </div>
  );
}
```

중괄호 안에는 다음과 같은 것들을 넣을 수 있습니다:
- 변수: `{name}`
- 함수 호출: `{getName()}`
- 계산식: `{age + 1}`
- 삼항 연산자: `{isStudent ? '학생' : '일반인'}`
- 배열 메서드: `{items.map(...)}`

보통의 Javascript + HTML 방식과 비교했을 때, 더 편리하고 직관적이지 않나요?

### 2. 속성(Attributes) 설정

HTML에서는 태그 내부에 속성을 추가하여 추가 정보를 부여할 수 있었습니다.

JSX에서도 비슷하게 속성을 설정할 수 있습니다.

HTML 속성과 비슷하지만 몇 가지 차이점이 있습니다.

```jsx
function App() {
  const imageUrl = 'https://via.placeholder.com/150';
  const altText = '예시 이미지';

  return (
    <div>
      {/* 문자열 속성: 값 부분에 문자열을 부여 */}
      <img src={imageUrl} alt={altText} />
      
      {/* 동적 속성 */}
      <input 
        type="text" 
        placeholder="이름을 입력하세요"
        className="input-field"
        disabled={false}
      />
      
      {/* 인라인 스타일 (객체 형태) */}
      <div style={{
        color: 'blue',
        fontSize: '16px',
        backgroundColor: 'lightgray'
      }}>
        스타일이 적용된 div
      </div>
    </div>
  );
}
```

<CalloutBox type="warning" title="HTML과 다른 속성들">
**className**: HTML의 `class` 대신 `className`을 사용합니다

**htmlFor**: HTML의 `for` 대신 `htmlFor`를 사용합니다 (label 태그에서)

**style**: 문자열이 아닌 객체 형태로 전달합니다

**camelCase**: onClick, onSubmit 등 이벤트 핸들러는 카멜케이스로 작성합니다
</CalloutBox>

### 3. 자식 요소들

JSX에서는 중첩된 요소들을 HTML처럼 자연스럽게 작성할 수 있습니다.

중괄호 안에 JavaScript를 넣어 표현식을 바로 사용할 수 있는 JSX의 특징이자 장점이죠.

```jsx
function App() {
  const todos = ['React 공부하기', 'JSX 익히기', '프로젝트 만들기'];

  return (
    <div className="container">
      <header>
        <h1>할 일 목록</h1>
      </header>
      
      <main>
        <ul>
          {todos.map((todo, index) => (
            <li key={index}>{todo}</li>
          ))}
        </ul>
      </main>
      
      <footer>
        <p>총 {todos.length}개의 할 일</p>
      </footer>
    </div>
  );
}
```

---

## JSX 작성 규칙

### 1. 하나의 최상위 요소

JSX에서는 여러 요소를 반환할 때 반드시 하나의 부모 요소로 감싸야 합니다.

이 때, React에서 제공하는 <HighlightWord>React Fragment</HighlightWord>를 사용하거나, 일반적인 HTML 태그로 감쌀 수 있습니다.

빈 태그 `<>...</>`로 간단하게 사용하거나 ```<React.Fragment>```로 명시적으로 사용할 수 있습니다.

```jsx
// ❌ 잘못된 예시 - 에러 발생
function App() {
  return (
    <h1>제목</h1>
    <p>내용</p>
  );
}

// ✅ 올바른 예시 1 - div로 감싸기
function App() {
  return (
    <div>
      <h1>제목</h1>
      <p>내용</p>
    </div>
  );
}

// ✅ 올바른 예시 2 - React Fragment 사용
function App() {
  return (
    <>
      <h1>제목</h1>
      <p>내용</p>
    </>
  );
}

// ✅ 올바른 예시 3 - React.Fragment 명시적 사용
function App() {
  return (
    <React.Fragment>
      <h1>제목</h1>
      <p>내용</p>
    </React.Fragment>
  );
}
```

<HighlightWord>React Fragment(`<>...</>`)</HighlightWord>는 불필요한 div 래퍼 없이 여러 요소를 그룹화할 수 있게 해줍니다. 실제 DOM에는 추가 요소가 생성되지 않습니다.

### 2. 태그는 반드시 닫아주기

HTML에서는 일부 태그를 닫지 않아도 되지만, JSX에서는 모든 태그를 반드시 닫아야 합니다.

```jsx
// ✅ 올바른 예시
function App() {
  return (
    <div>
      <img src="image.jpg" alt="이미지" />
      <input type="text" />
      <br />
      <hr />
    </div>
  );
}
```

---

## 조건부 렌더링

JSX에서는 JavaScript의 조건문을 활용해 상황에 따라 다른 UI를 보여줄 수 있습니다.

### 1. 삼항 연산자 사용

Javascript를 포함해 여러 프로그래밍 언어에서 자주 사용되는 삼항 연산자를 활용할 수 있습니다.

삼항 연산자란, 조건에 따라 두 가지 값을 선택하는 간단한 방법입니다.

```조건식 ? 참일 때의 값 : 거짓일 때의 값``` 와 같은 형태로 조건식에 대한 분기를 작성할 수 있습니다.

<br/>

아래 예시는 로그인 된 상태 ``` isLoggedIn = true ```일 때 사용자 이름을 보여주고, 로그인 되지 않은 상태일 때는 로그인 요청 메시지를 보여주는 예시입니다.

또한 user의 레벨에 따라 다른 메시지를 보여줍니다.

```jsx
function App() {
  const isLoggedIn = true;
  const user = { name: '김리액트', level: 'beginner' };

  return ( 
    <div>
      <h1>
        {isLoggedIn ? `안녕하세요, ${user.name}님!` : '로그인해주세요'}
      </h1>
      
      <div>
        {user.level === 'beginner' ? (
          <p>🌱 React 초보자이시군요!</p>
        ) : (
          <p>🚀 React 고수이시네요!</p>
        )}
      </div>
    </div>
  );
}
```

### 2. 논리 AND 연산자 사용

논리 연산자 `&&`를 사용해서 조건이 참일 때만 특정 요소를 렌더링할 수 있습니다.

앞의 식이 참인 경우, 뒤의 식을 렌더링합니다.

```jsx
function App() {
  const showWelcome = true;
  const notifications = ['새 메시지', '친구 요청'];

  return (
    <div>
      {showWelcome && <h1>환영합니다!</h1>}
      
      {notifications.length > 0 && (
        <div>
          <h3>알림 ({notifications.length}개)</h3>
          <ul>
            {notifications.map((item, index) => (
              <li key={index}>{item}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}
```

하지만 주의할 점이 있습니다.

가령, ``` {items.length && <p>{items.length}개의 아이템</p>} ``` 과 같은 표현식이 있다고 가정해봅시다.

이 경우, items의 길이가 0일 때는 출력하지 않도록 설계한 것이지만, <HighlightWord>실제로는 0이 렌더링</HighlightWord>되는 현상이 발생합니다.

따라서, ``` {items.length > 0 && <p>{items.length}개의 아이템</p>} ```와 같이 조건을 명시적으로 작성하는 것이 좋습니다.

<br/>

또한 <HighlightWord>boolean 값은 직접적으로 렌더링되지 않습니다.</HighlightWord>

```true```, ```false```, ```null```, ```undefined``` 값은 JSX에서 렌더링되지 않으므로, 조건부 렌더링을 할 때는 주의해야 합니다.

하지만 0은 제외이므로 유의합시다.

<br/>

### 3. 함수를 사용한 복잡한 조건부 렌더링

javascript 함수를 활용해 조건부 렌더링을 처리할 수 있습니다.

함수 내에서 return 문을 사용해 조건에 따라 다른 JSX를 반환할 수 있습니다.

이 함수를 JSX 내에서 호출하면 return된 JSX가 렌더링됩니다.

```jsx
function App() {
  const user = {
    name: '김리액트',
    role: 'admin',
    isActive: true
  };

  const renderUserStatus = () => {
    if (!user.isActive) {
      return <span style={{ color: 'red' }}>🚫 비활성화된 사용자</span>;
    }
    
    if (user.role === 'admin') {
      return <span style={{ color: 'purple' }}>👑 관리자</span>;
    }
    
    return <span style={{ color: 'green' }}>👤 일반 사용자</span>;
  };

  return (
    <div>
      <h1>{user.name}</h1>
      {renderUserStatus()}
    </div>
  );
}
```

---

## 리스트 렌더링

배열 데이터를 JSX로 렌더링하는 방법을 알아보겠습니다.

배열을 map 메서드로써 반복 렌더링할 때, 주의할 점은 각 아이템에 고유한 `key` 속성을 부여하는 것입니다.

이 `key`는 React가 어떤 아이템이 변경되었는지, 추가되었는지, 삭제되었는지를 효율적으로 파악할 수 있게 도와줍니다.

따라서 `key`를 부여하지 않는다면 성능에 영향을 줄 수 있으며 경고 오류를 출력합니다.


<Image
  src="/content/beginner/4/key-error.png"
  alt="key 오류 예시"
  width="two-thirds"
  caption="key 속성이 없는 리스트 렌더링 시 에러 발생"
/>

<br/>

map으로 반복 렌더링을 할 때는 반드시 최상단 요소에 `key` 속성을 추가합시다.

`key` 속성은 고유한 값을 사용해야 하며, <HighlightWord>일반적으로 데이터만 가지고 있는 고유 ID</HighlightWord>를 사용합니다.

또는 배열의 인덱스를 사용할 수도 있지만, <HighlightWord>데이터가 변경될 가능성이 있는 경우에는 권장하지 않습니다</HighlightWord>.

```jsx
function App() {
  const fruits = [
    { id: 1, name: '사과', color: 'red', price: 1000 },
    { id: 2, name: '바나나', color: 'yellow', price: 500 },
    { id: 3, name: '포도', color: 'purple', price: 2000 }
  ];

  return (
    <div>
      <h1>과일 목록</h1>
      
      {/* 기본 리스트 렌더링 */}
      <ul>
        {fruits.map(fruit => (
          <li key={fruit.id}>
            {fruit.name} - {fruit.price}원
          </li>
        ))}
      </ul>

      {/* 더 복잡한 리스트 렌더링 */}
      <div>
        {fruits.map(fruit => (
          <div key={fruit.id}>
            <h3 style={{ color: fruit.color }}>{fruit.name}</h3>
            <p>색상: {fruit.color}</p>
            <p>가격: {fruit.price.toLocaleString()}원</p>
            <button>장바구니 담기</button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

<CalloutBox type="warning" title="key 속성의 중요성">
**고유한 값**: 각 리스트 아이템은 형제들 사이에서 고유한 key를 가져야 합니다

**배열 인덱스 피하기**: 가능하면 배열 인덱스 대신 데이터의 고유 ID를 사용하세요

**성능 최적화**: React가 어떤 아이템이 변경되었는지 효율적으로 파악할 수 있게 합니다

```jsx
// ❌ 권장하지 않음
{items.map((item, index) => <li key={index}>{item}</li>)}

// ✅ 권장
{items.map(item => <li key={item.id}>{item.name}</li>)}
```
</CalloutBox>

---

## 이벤트 처리

JSX에서는 HTML 이벤트와 비슷하지만 조금 다른 방식으로 이벤트를 처리합니다.

우선 일반 javascript와 마찬가지로 이벤트 핸들러를 함수로 정의하고, JSX에서 해당 함수를 이벤트 속성에 할당합니다.


```jsx
function App() {
  const handleClick = () => {
    alert('버튼이 클릭되었습니다!');
  };

  const handleInputChange = (event) => {
    console.log('입력값이 변경되었습니다: ', event.target.value);
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log('폼이 제출되었습니다!');
  };

  return (
    <div>
      {/* 클릭 이벤트 */}
      <button onClick={handleClick}>
        클릭하세요
      </button>

      {/* 인라인 함수 */}
      <button onClick={() => alert('인라인 함수!')}>
        인라인 클릭
      </button>

      {/* 매개변수가 있는 함수 */}
      <button onClick={() => handleClick('매개변수')}>
        매개변수 전달
      </button>

      {/* 입력 이벤트 */}
      <input 
        type="text" 
        placeholder="입력해보세요"
        onChange={handleInputChange}
      />

      {/* 폼 이벤트 */}
      <form onSubmit={handleSubmit}>
        <input type="text" placeholder="이름" />
        <button type="submit">제출</button>
      </form>
    </div>
  );
}
```

### 일반적인 이벤트 핸들러들

javascript에서는 `addEventListener`를 사용해 이벤트를 처리했지만, JSX에서는 이벤트 핸들러를 직접 속성으로 지정합니다.

이 방식이 조금 더 직관적이고 React의 컴포넌트 기반 구조와 잘 어울립니다.

한눈에 들어오니 이해가 더 잘 되지 않나요?

```jsx
function App() {
  return (
    <div>
      <button onClick={() => console.log('클릭!')}>클릭</button>
      
      <input 
        onFocus={() => console.log('포커스됨')}
        onBlur={() => console.log('포커스 해제됨')}
        onChange={(e) => console.log('값 변경:', e.target.value)}
      />
      
      <div 
        onMouseEnter={() => console.log('마우스 진입')}
        onMouseLeave={() => console.log('마우스 이탈')}
        style={{ padding: '20px', backgroundColor: 'lightblue' }}
      >
        마우스를 올려보세요
      </div>
      
      <form onSubmit={(e) => { e.preventDefault(); console.log('폼 제출'); }}>
        <button type="submit">제출</button>
      </form>
    </div>
  );
}
```

---

## 스타일링

JSX에서 스타일을 적용하는 여러 가지 방법을 알아보겠습니다.

### 1. 인라인 스타일

JSX 태그에 style 속성을 사용해 인라인 스타일을 적용할 수 있습니다.

인라인 스타일은 객체 형태로 작성하며, CSS 속성 이름은 카멜케이스로 작성합니다.

이 때, <HighlightWord>인라인 스타일로 지정한 스타일은 CSS 클래스보다 우선 적용</HighlightWord>됩니다.

우선순위가 높게 잡힌다는 의미입니다.

우선순위를 정리하면, ```외부 CSS``` < ```CSS 클래스``` < ```인라인 스타일``` < ```!important``` 순입니다.

```jsx
function App() {
  const boxStyle = {
    width: '200px',
    height: '200px',
    backgroundColor: 'lightblue',
    border: '2px solid blue',
    borderRadius: '10px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  };

  return (
    <div>
      {/* 직접 객체 전달 */}
      <div style={{ color: 'red', fontSize: '18px' }}>
        빨간 텍스트
      </div>

      {/* 변수로 스타일 객체 전달 */}
      <div style={boxStyle}>
        스타일 박스
      </div>

      {/* 조건부 스타일 */}
      <div style={{ 
        color: true ? 'green' : 'red',
        fontWeight: 'bold' 
      }}>
        조건부 스타일
      </div>
    </div>
  );
}
```

### 2. CSS 클래스 사용

```jsx
function App() {
  const isActive = true;
  const theme = 'dark';

  return (
    <div>
      {/* 기본 클래스 */}
      <div className="container">
        컨테이너
      </div>

      {/* 조건부 클래스 */}
      <div className={isActive ? 'active' : 'inactive'}>
        상태에 따른 클래스
      </div>

      {/* 여러 클래스 조합 */}
      <div className={`box ${theme} ${isActive ? 'active' : ''}`}>
        여러 클래스
      </div>
    </div>
  );
}
```

---

## 주석 작성하기

JSX에서 주석을 작성하는 방법입니다.

```jsx
function App() {
  return (
    <div>
      {/* JSX 주석은 이렇게 작성합니다 */}
      <h1>제목</h1>
      
      {/* 
        여러 줄 주석도 
        이렇게 작성할 수 있습니다 
      */}
      <p>내용</p>
      
      {/* 조건부 렌더링에서도 주석 활용 */}
      {true && (
        <div>
          {/* 이 부분은 true일 때만 렌더링됩니다 */}
          <span>표시됨</span>
        </div>
      )}
    </div>
  );
}
```

---

## JSX 사용 시 주의사항

<CalloutBox type="warning" title="JSX 사용 시 주의점">
**중괄호 안의 객체**: 객체를 직접 렌더링할 수 없음 - `{user}` ❌, `{user.name}` ✅

**undefined와 null**: 이 값들은 렌더링되지 않음

**boolean 값**: true/false도 렌더링되지 않음

**함수 호출**: 함수 자체가 아닌 함수 호출 결과를 사용

```jsx
// ❌ 잘못된 예시들
<div>{user}</div>  // 객체는 렌더링 불가
<div>{true}</div>  // boolean은 렌더링되지 않음
<div>{someFunction}</div>  // 함수 자체가 아닌 호출 결과를

// ✅ 올바른 예시들
<div>{user.name}</div>  // 객체의 속성
<div>{true ? '참' : '거짓'}</div>  // 조건부 렌더링
<div>{someFunction()}</div>  // 함수 호출 결과
```
</CalloutBox>

---

## 복습 퀴즈

<Quiz
 question="JSX에서 JavaScript 표현식을 삽입할 때 사용하는 기호는?"
 options={[
   "소괄호 ()",
   "중괄호 {}",
   "대괄호 []",
   "꺾쇠괄호 <>"
 ]}
 correctAnswer={1}
 explanation="JSX에서는 중괄호 {}를 사용해서 JavaScript 표현식을 삽입할 수 있습니다."
/>

<Quiz
 question="JSX에서 HTML의 'class' 속성을 대신해서 사용하는 속성명은?"
 options={[
   "class",
   "className",
   "cssClass",
   "htmlClass"
 ]}
 correctAnswer={1}
 explanation="JSX에서는 JavaScript의 예약어 'class'와 구분하기 위해 'className'을 사용합니다."
/>

<Quiz
 question="JSX에서 여러 요소를 감싸지 않고 반환하려면 무엇을 사용해야 할까요?"
 options={[
   "div 태그",
   "span 태그",
   "React Fragment (<> </>)",
   "section 태그"
 ]}
 correctAnswer={2}
 explanation="React Fragment(<> </>)를 사용하면 불필요한 DOM 요소 없이 여러 요소를 그룹화할 수 있습니다."
/>

<Quiz
 question="다음 중 JSX에서 렌더링되지 않는 값은?"
 options={[
   "문자열",
   "숫자",
   "boolean (true/false)",
   "배열"
 ]}
 correctAnswer={2}
 explanation="JSX에서는 boolean 값(true/false), null, undefined는 렌더링되지 않습니다."
/>

---

## 참고 자료

<LinkCard 
  title="React 공식 문서 - JSX 소개" 
  url="https://ko.react.dev/learn/writing-markup-with-jsx" 
  description="React 공식 문서에서 JSX에 대해 더 자세히 알아보세요" 
/>

<LinkCard 
  title="React 공식 문서 - 조건부 렌더링" 
  url="https://ko.react.dev/learn/conditional-rendering" 
  description="조건부 렌더링에 대한 더 자세한 내용과 고급 패턴들을 확인해보세요" 
/>

---

<CalloutBox type="success" title="🎉 축하합니다!">
JSX의 핵심 문법을 모두 학습했습니다! 이제 React에서 HTML과 JavaScript를 자유자재로 활용할 수 있습니다. 

다음 강의에서는 React의 컴포넌트에 대해 배워보겠습니다.
</CalloutBox>