export const metadata = {
  id: 13,
  title: "React 디버깅 - 버그를 찾고 해결하는 방법",
  description: "React 개발 중 발생하는 버그를 효과적으로 찾고 해결하는 다양한 디버깅 방법을 학습합니다.",
  difficulty: "쉬움",
  tags: ["React", "디버깅", "개발도구", "console.log", "React DevTools", "입문"],
  lastUpdated: "2025-08-25",
  image: "http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/lesson-13-bg.png"
};

import { 
  CalloutBox, 
  HighlightWord, 
  Quiz, 
  LinkCard,
  Image
} from '@/components/CourseContent/EmbeddedComponents'

<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/error_example.png"
  alt="chrome 에러 출력"
  width="two-thirds"
/>

javascript로 개발을 하다 보면 예상과 다르게 동작하거나 에러가 발생하는 상황이 자주 발생합니다.

이런 문제들을 찾아내고 해결하는 과정을 '디버깅(Debugging)'이라고 합니다.

React 개발에서도 효과적인 디버깅 방법을 알고 있으면 문제를 빠르게 해결할 수 있습니다.

이번 시간에는 React에서 디버깅하는 방법들을 알아보겠습니다.

---

## JavaScript에서의 기본 디버깅 방법

React를 배우기 전에 JavaScript에서는 어떻게 디버깅을 했는지 브라우저에서의 방법과 서버(nodejs)에서의 방법으로 간단히 살펴보겠습니다.

### 클라이언트(브라우저)에서의 디버깅

브라우저에서 JavaScript 코드를 디버깅할 때는 주로 다음 방법들을 사용했습니다.
<br/>
방법 1. `console.log`로 값 확인

<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/consoleerror.png"
  alt="chrome consoleerror 출력"
  width="half"
/>

console.log()를 사용하여 변수나 함수의 값을 출력하고 크롬 등의 브라우저 콘솔 창을 통해 흐름을 확인했습니다.

console로 확인할 수 있는 메시지의 종류는 다음과 같습니다.

- `console.log()`: 일반 로그
- `console.error()`: 에러 로그 (빨간색)
- `console.warn()`: 경고 로그 (노란색)
- `console.table()`: 표 형태로 데이터 출력
- `console.group()`: 관련 로그를 그룹화
- `console.time()` / `console.timeEnd()`: 코드 실행 시간 측정


```javascript
function App(price, tax) {
  console.log('함수 호출 전');
  callTestFunction();
  console.log('함수 호출 후');
}

function callTestFunction() {
  try {
    임의의 활동();
  } catch (error) {
    console.error('함수 수행 중 에러 발생:', error.message);
  }
}
```

<br/>
방법 2. `debugger` 문 사용

<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/debugger-1.png"
  alt="chrome debugger"
  width="half"
  caption="sources 탭에서 변수가 변하기 전과 후의 값을 확인할 수 있다."
/>

`debugger` 문을 코드에 삽입하면, 브라우저의 개발자 도구 sources 탭이 열려 있을 때 해당 지점에서 실행이 멈추고, 

멈춘 당시 시점에서의 변수 값과 호출 스택 등을 확인할 수 있습니다.

```javascript
    function testDebugger() {
        console.log("함수 시작");
        debugger;
        console.log("함수 끝");
    }

    testDebugger();
```


<br/>
방법 3. 브라우저 Sources 탭에서 디버깅

<ImageGallery
  images={[
    { src: 'http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/debugger-2.png', alt: 'debugger 실행 모습 1', caption: 'Sources 탭에서 breakpoint 설정' },
    { src: 'http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/debugger-3.png', alt: 'debugger 실행 모습 2', caption: 'F10, F11 키로 단계별 실행' },
    { src: 'http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/debugger-4.png', alt: 'debugger 실행 모습 3', caption: '우측의 탭에서 call stack과 현재 라인, 함수 정보와 반복문 등의 블록 정보를 확인 할 수 있다.' }
  ]}
/>

debugger와 다른 점은, 따로 `debugger` 문을 삽입하지 않고도, 브라우저 개발자 도구의 Sources 탭에서 직접 코드 라인에 breakpoint(중단점)를 설정할 수 있다는 점입니다.

이를 통해 <HighlightWord>F12 → Sources 탭에서 원하는 시점에 고정점을 두고, 해당 시점에서 살펴보고 싶은 값을 순서대로 이동하며 볼 수 있습니다.</HighlightWord>

```javascript
function complexCalculation(numbers) {
  // F11을 누르면 이 함수 내부로 들어감
  let sum = 0;
  for (let i = 0; i < numbers.length; i++) {
    sum += numbers[i]; // 각 반복마다 F11로 단계별 확인
  }
  return sum;
}

// 브라우저에서:
// 1. F12로 개발자 도구 열기
// 2. Sources 탭 선택
// 3. 코드 라인에 breakpoint 설정 (줄 번호 클릭)
// 4. F11 (Step Into): 함수 내부로 들어가기
// 5. F10 (Step Over): 다음 줄로 넘어가기  
// 6. Shift+F11 (Step Out): 함수에서 나가기
```

### Node.js 서버에서의 디버깅

서버 환경에서는 다음과 같은 방법들을 사용했습니다
<br/>
방법 1. console.log로 서버 로그 출력

<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/nodeconsole.png"
  alt="vscode debugger"
  width="half"
  caption="console.log로 서버 터미널에서 로그를 출력한다,"
/>

브라우저와 마찬가지로 vscode나 터미널에서 서버 로그를 통해 흐름과 변수 값을 확인했습니다.

<br/>
방법 2. vscode 디버깅 기능 활용

<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/nodedebug.png"
  alt="vscode debugger"
  width="full"
  caption="sources 탭과 마찬가지로 breakpoint 설정, 단계별 실행, 변수 값 확인 등이 가능하다."
/>

vscode에서는 내장된 디버깅 기능을 통해 Node.js 애플리케이션을 디버깅할 수 있습니다.

브라우저 sources 탭과 유사하게 breakpoint 설정, 단계별 실행, 변수 값 확인 등이 가능합니다.

라인을 눌러 멈추고 싶은 시점을 설정하여 F10, F11 키로 단계별 실행하며 흐름을 추적할 수 있습니다.


---

## React에서의 디버깅 방법

React에서는 기존 JavaScript 디버깅 방법에 더해 <HighlightWord>함수형 컴포넌트와 최신 Hooks를 활용한 특화된 디버깅 도구들</HighlightWord>을 사용할 수 있습니다.

<br/>
## 1. console.log를 활용한 기본 디버깅

가장 기본적이지만 효과적인 방법입니다. React 19의 함수형 컴포넌트에서 상태나 props 값을 확인할 때 유용합니다.

### 컴포넌트 렌더링 확인

```jsx
function UserProfile({ userId, userName }) {
  console.log('UserProfile 렌더링됨');
  console.log('받은 props:', { userId, userName });
  
  return (
    <div>
      <h2>{userName}</h2>
      <p>사용자 ID: {userId}</p>
    </div>
  );
}
```
위 예시처럼 컴포넌트가 렌더링 될 때마다의 props나 데이터값을 console.log로 확인할 수 있습니다.

아래 예시 코드처럼 `useEffect` 훅 내부에서 상태 변화나 비동기 작업에 로그를 남겨 에러가 발생했을 때 어느 시점에서 문제가 생겼는지 추적할 수 있습니다.

```jsx
import { useState, useEffect } from 'react';

function DataFetcher({ url }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    console.log('useEffect 실행됨, URL:', url);
    
    setLoading(true);
    
    fetch(url)
      .then(response => {
        console.log('응답 받음:', response.status);
        return response.json();
      })
      .then(data => {
        console.log('데이터 받음:', data);
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        console.error('에러 발생:', error);
        setLoading(false);
      });
      
    return () => {
      console.log('useEffect cleanup 실행됨');
    };
  }, [url]);
  
  if (loading) return <div>로딩 중...</div>;
  if (!data) return <div>데이터 없음</div>;
  
  return <div>{JSON.stringify(data)}</div>;
}
```

---

## 2. React Developer Tools 사용하기

<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/reactdevtool.png"
  alt="react devtool setup"
  width="full"
  caption="sources 탭과 마찬가지로 breakpoint 설정, 단계별 실행, 변수 값 확인 등이 가능하다."
/>

React Developer Tools는 <HighlightWord>React와 호환되는 전용 브라우저 확장 프로그램</HighlightWord>으로, 최신 기능들과 함께 컴포넌트 구조와 상태를 시각적으로 확인할 수 있습니다.

### React DevTools 설치

1. Chrome 웹 스토어에서 "React Developer Tools" 검색
2. 확장 프로그램 설치 (React 19 호환 버전)
3. 웹페이지에서 F12를 누르고 "Components" 탭 확인


```jsx
import { useState } from 'react';

function TodoApp() {
  const [todos, setTodos] = useState([
    { id: 1, text: '리액트 19 공부하기', completed: false },
    { id: 2, text: '디버깅 연습하기', completed: true }
  ]);
  
  const toggleTodo = (id) => {
    setTodos(prev => prev.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  return (
    <div>
      <h1>할 일 목록</h1>
      {todos.map(todo => (
        <TodoItem 
          key={todo.id} 
          todo={todo} 
          onToggle={() => toggleTodo(todo.id)}
        />
      ))}
    </div>
  );
}

function TodoItem({ todo, onToggle }) {
  return (
    <div onClick={onToggle}>
      {todo.completed ? '✅' : '⭕'} {todo.text}
    </div>
  );
}
```

브라우저의 `components` 탭을 클릭하면 위 예시 코드의 컴포넌트 트리 구조와 각 컴포넌트의 props, state 값을 실시간으로 확인할 수 있습니다.

<Image
  src="http://subdevpi.duckdns.org:3000/file/react-step/content/beginner/13/devtool.png"
  alt="react devtool"
  width="full"
/>

---

## 3. React 19의 Error Boundary 활용

React 19에서는 함수형 컴포넌트에서도 에러 처리를 더 효과적으로 할 수 있습니다.

```jsx
import { useState, useEffect } from 'react';

// Wrapper로 감싼 영역에서 에러가 발생하면 Wrapper 컴포넌트에서 감지하고, 그에 맞는 UI를 출력합니다.
function ErrorBoundaryWrapper({ children }) {
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const handleError = (event) => {
      console.error('전역 에러 발생:', event.error);
      setError(event.error);
    };
    
    window.addEventListener('error', handleError);
    window.addEventListener('unhandledrejection', handleError);
    
    return () => {
      window.removeEventListener('error', handleError);
      window.removeEventListener('unhandledrejection', handleError);
    };
  }, []);
  
  if (error) {
    return (
      <div>
        <h2>문제가 발생했습니다!</h2>
        <p>에러: {error.message}</p>
        <button onClick={() => setError(null)}>다시 시도</button>
      </div>
    );
  }
  
  return children;
}

// 에러 발생 컴포넌트
function RiskyComponent() {
  const [shouldError, setShouldError] = useState(false);
  
  if (shouldError) {
    throw new Error('의도적으로 발생시킨 에러입니다');
  }
  
  return (
    <div>
      <p>정상 동작 중</p>
      <button onClick={() => setShouldError(true)}>
        에러 발생시키기
      </button>
    </div>
  );
}

// Wrapper에 감싸진 컴포넌트에서 에러가 발생하면 Wrapper에서 처리
function App() {
  return (
    <ErrorBoundaryWrapper>
      <RiskyComponent />
    </ErrorBoundaryWrapper>
  );
}
```

---

## 4. 조건부 렌더링으로 디버깅

개발 중에만 디버그 정보를 보여주는 방법입니다.

ENV 파일을 활용해 개발 환경과 운영 환경을 구분하고 이를 통해서 개발 환경에서만 보이는 디버그 컴포넌트를 만들 수 있습니다.

production 환경에서 console.log를 지우지 않고도 빌드-배포할 수 있다는 것이 장점입니다.

```jsx
import { useState } from 'react';

function DebugInfo({ data, label }) {
  // 개발 환경에서만 표시
  if (process.env.NODE_ENV !== 'development') {
    return null;
  }
  
  return (
    <div>
      <strong>{label}:</strong>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}

function UserComponent({ user }) {
  const [loading, setLoading] = useState(false);
  
  return (
    <div>
      <h2>{user.name}</h2>
      
      {/* 개발 중에만 보이는 디버그 정보 */}
      <DebugInfo data={{ user, loading }} label="컴포넌트 상태" />
      
      <p>이메일: {user.email}</p>
    </div>
  );
}
```

---

## 5. React 19의 새로운 Hooks를 활용한 디버깅

React 19에서는 새로운 Hooks들이 디버깅에 도움을 줍니다.

### use Hook을 활용한 디버깅

React 19에서는 `use`라는 새로운 Hook이 도입되었습니다.

`use`는 Promise를 직접 기다렸다가 결과를 반환하는 기능을 제공합니다.

그렇기에, Promise를 직접 처리할 수 있어 비동기 데이터를 다룰 때 유용합니다.

`use`의 자세한 사용방법은 중급 과정에서 자세히 다루겠습니다.

```jsx
import { useState, use } from 'react';

function DataComponent({ userPromise }) {
  // React 19의 use Hook으로 Promise 처리
  const user = use(userPromise);
  
  console.log('use Hook으로 받은 사용자 데이터:', user);
  
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}

function ErrorBoundary({ children, fallback }) {
  return (
    <React.ErrorBoundary fallbackRender={({ error }) => fallback(error)}>
      {children}
    </React.ErrorBoundary>
  );
}

// Suspense와 함께 사용
function App() {
  const userPromise = fetch('/api/user').then(res => res.json());
  
  return (
    <ErrorBoundary fallback={(error) => <div>에러 발생: {error.message}</div>}>
        <Suspense fallback={<div>로딩 중...</div>}>
            <DataComponent userPromise={userPromise} />
        </Suspense>
     </ErrorBoundary>
  );
}
```
<br/>
위 처럼 `use` Hook 내부에서 Promise 작업을 수행(호출)하면, 
<br/>
아직 promise가 대기 상태라면 → 컴포넌트를 멈추고(throw), React가 Suspense fallback을 보여줌.

promise가 완료되면 → 값(데이터)을 반환해서 변수처럼 사용 가능.

promise가 실패하면 → 에러를 throw해서 ErrorBoundary로 처리됨.
<br/>

---

## 복습 퀴즈

<Quiz
 question="React에서 함수형 컴포넌트의 상태 변화를 추적하기 위한 가장 기본적인 방법은?"
 options={[
   "React DevTools만 사용",
   "console.log()와 useState 조합 활용",
   "debugger 문만 사용",
   "use Hook만 사용"
 ]}
 correctAnswer={1}
 explanation="console.log()와 useState를 조합하여 상태 변화 시점과 값을 추적하는 것이 가장 기본적이고 직관적인 방법입니다."
/>

<Quiz
 question="브라우저 Sources 탭에서 단계별 디버깅을 위해 사용하는 키는?"
 options={[
   "F10 (Step Over), F11 (Step Into)",
   "F12 (DevTools), F5 (Refresh)",
   "Ctrl+C, Ctrl+V",
   "F1 (Help), F9 (Run)"
 ]}
 correctAnswer={0}
 explanation="F10은 Step Over(다음 줄로), F11은 Step Into(함수 내부로 들어가기)로 단계별 디버깅에 사용됩니다."
/>

<Quiz
 question="React 19의 use Hook을 디버깅할 때 주의해야 할 점은?"
 options={[
   "use Hook은 디버깅이 불가능하다",
   "Promise의 성공/실패 상태를 모두 추적해야 한다",
   "use Hook은 console.log만 사용 가능하다",
   "React DevTools에서 확인할 수 없다"
 ]}/>